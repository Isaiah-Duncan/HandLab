<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Color Memory Touch - Space Edition</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      /* Base Colors */
      --space-black: #0D0D1A;
      --cloud-white: #F0F0F5;

      /* Neon Cosmic Accents */
      --cosmic-purple: #8A2BE2;
      --cosmic-cyan: #00E5FF;
      --cosmic-pink: #FF1493;
      --cosmic-yellow: #FFD700;

      /* UI Backgrounds */
      --container-bg: rgba(13, 13, 26, 0.9);
      --container-border: rgba(138, 43, 226, 0.5);

      /* Text Colors */
      --text-primary: #F0F0F5;
      --text-secondary: #A0A4C8;

      /* Game Elements */
      --success-glow: rgba(0, 229, 255, 0.8);
      --error-glow: rgba(255, 20, 147, 0.8);

      /* Finger Colors */
      --red: #FF5757;
      --yellow: #FFD700;
      --green: #4CAF50;
      --blue: #2196F3;
      --purple: #9C27B0;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Nunito', -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", sans-serif;
      background: var(--space-black);
      color: var(--text-primary);
      overflow: hidden;
      height: 100vh;
      width: 100vw;
    }

    /* Canvas Container */
    #canvas-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    #bg-canvas, #video, #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    #bg-canvas {
      z-index: 1;
    }

    #video {
      display: none;
    }

    #canvas {
      transform: scaleX(-1);
      z-index: 2;
    }

    /* UI Overlay */
    .ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      pointer-events: none;
    }

    .ui-overlay > * {
      pointer-events: auto;
    }

    /* Top Bar */
    .top-bar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 70px;
      background: var(--container-bg);
      border-bottom: 2px solid var(--container-border);
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      padding: 0 20px;
      z-index: 100;
      box-shadow: 0 4px 20px rgba(138, 43, 226, 0.3);
    }

    .top-bar-left, .top-bar-right {
      display: flex;
      gap: 16px;
      align-items: center;
    }

    .top-bar-left {
      justify-self: start;
    }

    .top-bar-center {
      justify-self: center;
    }

    .top-bar-right {
      justify-self: end;
    }

    /* Icon Button */
    .icon-btn {
      width: 40px;
      height: 40px;
      border: none;
      background: transparent;
      font-size: 24px;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .icon-btn:hover {
      background: rgba(138, 43, 226, 0.2);
      box-shadow: 0 0 12px rgba(138, 43, 226, 0.6);
    }

    /* Lives Container */
    .lives-container {
      display: flex;
      gap: 10px;
      align-items: center;
      padding: 8px 16px;
      background: rgba(13, 13, 26, 0.8);
      border: 2px solid rgba(138, 43, 226, 0.5);
      border-radius: 16px;
    }

    .heart {
      font-size: 28px;
      transition: all 0.3s ease;
      animation: heartbeat 1.5s ease-in-out infinite;
    }

    .heart.active {
      filter: drop-shadow(0 0 8px rgba(255, 100, 100, 0.6));
    }

    .heart.lost {
      opacity: 0.3;
      animation: none;
      filter: grayscale(100%);
    }

    .heart.breaking {
      animation: heartBreak 0.5s ease-out;
    }

    @keyframes heartbeat {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    @keyframes heartBreak {
      0% { transform: scale(1) rotate(0deg); }
      25% { transform: scale(1.3) rotate(-10deg); }
      50% { transform: scale(0.8) rotate(10deg); }
      75% { transform: scale(1.2) rotate(-5deg); }
      100% { transform: scale(1) rotate(0deg); opacity: 0.3; }
    }

    /* Streak Container */
    .streak-container {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 16px;
      background: rgba(13, 13, 26, 0.8);
      border: 2px solid rgba(255, 165, 0, 0.6);
      border-radius: 16px;
      position: relative;
    }

    .streak-emoji {
      font-size: 28px;
      transition: transform 0.3s ease;
      filter: drop-shadow(0 0 8px rgba(255, 165, 0, 0.8));
    }

    .streak-emoji.streak-grow {
      animation: streakGrow 0.3s ease;
    }

    .streak-emoji.streak-reset {
      animation: streakShake 0.5s ease;
    }

    .streak-count {
      font-size: 20px;
      font-weight: 700;
      color: #FFD700;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
      transition: transform 0.3s ease;
    }

    .streak-count.streak-increment {
      animation: streakPop 0.3s ease;
    }

    .streak-count.streak-reset {
      animation: streakShake 0.5s ease;
      color: #888;
    }

    @keyframes streakGrow {
      0% { transform: scale(1); }
      50% { transform: scale(1.3) rotate(10deg); }
      100% { transform: scale(1); }
    }

    @keyframes streakPop {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }

    @keyframes streakShake {
      0%, 100% { transform: translateX(0); }
      20% { transform: translateX(-8px) rotate(-5deg); }
      40% { transform: translateX(8px) rotate(5deg); }
      60% { transform: translateX(-6px) rotate(-3deg); }
      80% { transform: translateX(6px) rotate(3deg); }
    }

    .streak-sparkle {
      position: absolute;
      font-size: 14px;
      animation: sparkleOut 1s ease-out forwards;
      pointer-events: none;
    }

    @keyframes sparkleOut {
      0% {
        transform: translate(0, 0) scale(0);
        opacity: 1;
      }
      100% {
        transform: translate(calc(cos(var(--angle)) * 50px), calc(sin(var(--angle)) * 50px)) scale(1);
        opacity: 0;
      }
    }

    /* Best Score */
    .best-score {
      text-align: right;
      padding: 8px 16px;
    }

    .score-label {
      font-size: 11px;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: 600;
    }

    .score-value {
      font-size: 28px;
      font-weight: 800;
      color: var(--cosmic-cyan);
      text-shadow: 0 0 12px rgba(0, 229, 255, 0.6);
    }

    .score-value.celebrating {
      animation: celebrate 0.5s ease;
    }

    @keyframes celebrate {
      0%, 100% { transform: scale(1); }
      25% { transform: scale(1.2); }
      50% { transform: scale(1.1); }
      75% { transform: scale(1.15); }
    }

    /* Progress Bar */
    #progress-container {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 50;
    }

    .progress-bar-container {
      width: 600px;
      max-width: 80vw;
      padding: 16px 24px;
      background: var(--container-bg);
      border: 2px solid var(--container-border);
      border-radius: 20px;
      box-shadow: 0 0 20px rgba(138, 43, 226, 0.3);
    }

    .progress-bar-track {
      width: 100%;
      height: 20px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 10px;
      overflow: hidden;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
      margin-bottom: 8px;
    }

    .progress-bar-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg,
        rgb(255, 87, 87) 0%,
        rgb(255, 215, 0) 25%,
        rgb(76, 175, 80) 50%,
        rgb(33, 150, 243) 75%,
        rgb(168, 85, 247) 100%);
      border-radius: 10px;
      transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 0 12px rgba(255, 255, 255, 0.4);
      position: relative;
    }

    .progress-bar-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.3) 50%, rgba(255,255,255,0) 100%);
      animation: shimmer 2s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .progress-label {
      text-align: center;
      color: var(--text-primary);
      font-size: 12px;
      font-weight: 600;
    }

    /* Game Center */
    .game-center {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 20;
    }

    /* Game Screen */
    .game-screen {
      background: var(--container-bg);
      border: 2px solid var(--container-border);
      border-radius: 24px;
      padding: 40px 60px;
      text-align: center;
      animation: fadeIn 0.5s ease;
      max-width: 500px;
      box-shadow: 0 0 40px rgba(138, 43, 226, 0.4);
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.9); }
      to { opacity: 1; transform: scale(1); }
    }

    .game-screen h1 {
      font-size: 36px;
      font-weight: 800;
      margin-bottom: 16px;
      background: linear-gradient(135deg, var(--red), var(--yellow), var(--green), var(--blue), var(--purple));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .game-screen p {
      color: var(--text-secondary);
      font-size: 16px;
      margin-bottom: 24px;
      line-height: 1.6;
    }

    .game-btn {
      background: linear-gradient(135deg, var(--cosmic-cyan), var(--cosmic-purple));
      border: none;
      border-radius: 12px;
      padding: 14px 36px;
      color: white;
      font-size: 16px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      margin: 8px;
      font-family: 'Nunito', sans-serif;
    }

    .game-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 24px rgba(0, 229, 255, 0.4);
    }

    .game-btn.secondary {
      background: transparent;
      border: 2px solid var(--container-border);
    }

    /* Game Over Stats */
    .game-over-stats {
      display: flex;
      justify-content: center;
      gap: 40px;
      margin: 24px 0;
    }

    .stat-item {
      text-align: center;
    }

    .stat-value {
      font-size: 36px;
      font-weight: 800;
      color: var(--cosmic-cyan);
    }

    .stat-label {
      font-size: 12px;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .new-high-score {
      color: var(--cosmic-yellow);
      font-size: 20px;
      font-weight: 700;
      margin-top: 16px;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* Tutorial */
    .tutorial-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 200;
      animation: fadeIn 0.3s ease;
    }

    .tutorial-content {
      background: var(--container-bg);
      border: 2px solid var(--container-border);
      border-radius: 24px;
      padding: 40px;
      max-width: 500px;
      text-align: center;
      box-shadow: 0 0 40px rgba(138, 43, 226, 0.4);
    }

    .tutorial-content h2 {
      font-size: 28px;
      margin-bottom: 20px;
      font-weight: 800;
    }

    .tutorial-fingers {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin: 30px 0;
      flex-wrap: wrap;
    }

    .tutorial-finger {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    .tutorial-finger .dot {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      box-shadow: 0 0 12px currentColor;
    }

    .tutorial-finger .name {
      font-size: 12px;
      color: var(--text-secondary);
      font-weight: 600;
    }

    /* Warning Banner */
    .warning-banner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 193, 7, 0.1);
      border: 2px solid var(--cosmic-yellow);
      border-radius: 16px;
      padding: 20px 40px;
      text-align: center;
      display: none;
      z-index: 15;
      color: var(--cosmic-yellow);
    }

    .warning-banner.show {
      display: block;
      animation: fadeIn 0.3s ease;
    }

    /* Confetti */
    #confetti-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1000;
    }

    .confetti-particle {
      position: fixed;
      width: 10px;
      height: 10px;
      top: -10px;
      border-radius: 2px;
      pointer-events: none;
      animation: confettiFall 3s ease-out forwards;
    }

    @keyframes confettiFall {
      to {
        transform: translateY(100vh) rotate(720deg);
        opacity: 0;
      }
    }

    /* Hidden */
    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>
  <div id="canvas-container">
    <!-- Background Layer -->
    <canvas id="bg-canvas"></canvas>

    <!-- Video & Hand Tracking -->
    <video id="video" playsinline></video>
    <canvas id="canvas"></canvas>

    <!-- UI Overlay -->
    <div class="ui-overlay">
      <!-- Top Bar -->
      <div class="top-bar">
        <div class="top-bar-left">
          <button class="icon-btn" onclick="goBack()" title="Back to menu">üè†</button>
        </div>

        <div class="top-bar-center">
          <div class="streak-container" id="streak-display"></div>
        </div>

        <div class="top-bar-right">
          <div class="lives-container" id="lives-display"></div>
          <div class="best-score">
            <div class="score-label">Best</div>
            <div class="score-value" id="best-score">0</div>
          </div>
        </div>
      </div>

      <!-- Game Center -->
      <div class="game-center" id="game-center">
        <!-- Start Screen -->
        <div class="game-screen" id="start-screen">
          <h1>Color Memory Touch</h1>
          <p>Watch the cosmic sequence light up, then touch your palm with the matching colored fingers. How far can you go?</p>
          <button class="game-btn" onclick="startGame()">Launch into Space üöÄ</button>
        </div>

        <!-- Game Over Screen -->
        <div class="game-screen hidden" id="game-over-screen">
          <h1>Mission Complete! üéØ</h1>
          <div class="game-over-stats">
            <div class="stat-item">
              <div class="stat-value" id="final-round">0</div>
              <div class="stat-label">Sequence Length</div>
            </div>
            <div class="stat-item">
              <div class="stat-value" id="final-touches">0</div>
              <div class="stat-label">Correct Touches</div>
            </div>
          </div>
          <div class="new-high-score hidden" id="new-high-score">üåü New High Score!</div>
          <button class="game-btn" onclick="startGame()">Launch Again üöÄ</button>
          <button class="game-btn secondary" onclick="goBack()">Back to Menu</button>
        </div>
      </div>

      <!-- Warning Banner -->
      <div class="warning-banner" id="warning-banner">
        ‚ö†Ô∏è Hand not detected - improve lighting or hand position
      </div>
    </div>

    <!-- Tutorial Overlay -->
    <div class="tutorial-overlay hidden" id="tutorial-overlay">
      <div class="tutorial-content">
        <h2>How to Play üéÆ</h2>
        <p>Each finger has a unique color. Watch the sequence light up at the top, then touch your palm with the correct colored fingers in order!</p>
        <div class="tutorial-fingers">
          <div class="tutorial-finger">
            <div class="dot" style="background: var(--red)"></div>
            <div class="name">Thumb</div>
          </div>
          <div class="tutorial-finger">
            <div class="dot" style="background: var(--yellow)"></div>
            <div class="name">Index</div>
          </div>
          <div class="tutorial-finger">
            <div class="dot" style="background: var(--green)"></div>
            <div class="name">Middle</div>
          </div>
          <div class="tutorial-finger">
            <div class="dot" style="background: var(--blue)"></div>
            <div class="name">Ring</div>
          </div>
          <div class="tutorial-finger">
            <div class="dot" style="background: var(--purple)"></div>
            <div class="name">Pinky</div>
          </div>
        </div>
        <p><strong>üí° Pro Tips:</strong><br>Hold your fingertip on the target for 0.3 seconds. 3 wrong touches = Game Over!</p>
        <button class="game-btn" onclick="closeTutorial()" style="margin-top: 20px;">Ready! üöÄ</button>
      </div>
    </div>

    <!-- Confetti -->
    <div id="confetti-container"></div>

    <!-- Progress Bar -->
    <div id="progress-container"></div>
  </div>

  <script>
    // ============================================
    // NEBULA BACKGROUND SYSTEM
    // ============================================

    class NebulaBackground {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.stars = [];
        this.nebulaClouds = [];
        this.width = canvas.width;
        this.height = canvas.height;
      }

      init() {
        // Create 200 twinkling stars
        for (let i = 0; i < 200; i++) {
          this.stars.push({
            x: Math.random() * this.width,
            y: Math.random() * this.height,
            radius: Math.random() * 2 + 0.5,
            brightness: Math.random(),
            twinkleSpeed: Math.random() * 0.02 + 0.01
          });
        }

        // Create 15 nebula clouds
        for (let i = 0; i < 15; i++) {
          this.nebulaClouds.push({
            x: Math.random() * this.width,
            y: Math.random() * this.height,
            radius: Math.random() * 300 + 100,
            color: this.getNebulaColor(),
            opacity: Math.random() * 0.3 + 0.1,
            driftX: (Math.random() - 0.5) * 0.2,
            driftY: (Math.random() - 0.5) * 0.2
          });
        }
      }

      getNebulaColor() {
        const colors = [
          { r: 138, g: 43, b: 226 },
          { r: 75, g: 0, b: 130 },
          { r: 255, g: 20, b: 147 },
          { r: 0, g: 191, b: 255 },
          { r: 147, g: 112, b: 219 }
        ];
        return colors[Math.floor(Math.random() * colors.length)];
      }

      render() {
        // Dark space background
        this.ctx.fillStyle = '#0D0D1A';
        this.ctx.fillRect(0, 0, this.width, this.height);

        // Draw nebula clouds
        this.nebulaClouds.forEach(cloud => {
          const gradient = this.ctx.createRadialGradient(
            cloud.x, cloud.y, 0,
            cloud.x, cloud.y, cloud.radius
          );
          gradient.addColorStop(0, `rgba(${cloud.color.r}, ${cloud.color.g}, ${cloud.color.b}, ${cloud.opacity})`);
          gradient.addColorStop(0.5, `rgba(${cloud.color.r}, ${cloud.color.g}, ${cloud.color.b}, ${cloud.opacity * 0.5})`);
          gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

          this.ctx.fillStyle = gradient;
          this.ctx.fillRect(cloud.x - cloud.radius, cloud.y - cloud.radius, cloud.radius * 2, cloud.radius * 2);

          cloud.x += cloud.driftX;
          cloud.y += cloud.driftY;

          if (cloud.x < -cloud.radius) cloud.x = this.width + cloud.radius;
          if (cloud.x > this.width + cloud.radius) cloud.x = -cloud.radius;
          if (cloud.y < -cloud.radius) cloud.y = this.height + cloud.radius;
          if (cloud.y > this.height + cloud.radius) cloud.y = -cloud.radius;
        });

        // Draw twinkling stars
        this.stars.forEach(star => {
          star.brightness += star.twinkleSpeed;
          if (star.brightness > 1 || star.brightness < 0) {
            star.twinkleSpeed *= -1;
          }

          this.ctx.fillStyle = `rgba(255, 255, 255, ${Math.abs(star.brightness)})`;
          this.ctx.beginPath();
          this.ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
          this.ctx.fill();
        });
      }
    }

    // ============================================
    // PROGRESS BAR COMPONENT
    // ============================================

    class ProgressBar {
      constructor(container, totalSteps) {
        this.container = container;
        this.totalSteps = totalSteps;
        this.currentStep = 0;
        this.bar = null;
        this.init();
      }

      init() {
        this.container.innerHTML = `
          <div class="progress-bar-container">
            <div class="progress-bar-track">
              <div class="progress-bar-fill" id="progress-fill"></div>
            </div>
            <div class="progress-label" id="progress-label">0/${this.totalSteps}</div>
          </div>
        `;
        this.bar = document.getElementById('progress-fill');
      }

      update(currentStep) {
        this.currentStep = currentStep;
        const percentage = (currentStep / this.totalSteps) * 100;
        this.bar.style.width = `${percentage}%`;
        document.getElementById('progress-label').textContent = `${currentStep}/${this.totalSteps}`;
      }

      reset(newTotalSteps) {
        this.totalSteps = newTotalSteps;
        this.currentStep = 0;
        this.container.innerHTML = `
          <div class="progress-bar-container">
            <div class="progress-bar-track">
              <div class="progress-bar-fill" id="progress-fill"></div>
            </div>
            <div class="progress-label" id="progress-label">0/${this.totalSteps}</div>
          </div>
        `;
        this.bar = document.getElementById('progress-fill');
      }
    }

    // ============================================
    // LIVES DISPLAY COMPONENT
    // ============================================

    class LivesDisplay {
      constructor(container) {
        this.container = container;
      }

      render(currentLives, maxLives) {
        this.container.innerHTML = '';

        for (let i = 0; i < maxLives; i++) {
          const heart = document.createElement('div');
          heart.className = 'heart';

          if (i < currentLives) {
            heart.classList.add('active');
            heart.innerHTML = '‚ù§Ô∏è';
          } else {
            heart.classList.add('lost');
            heart.innerHTML = 'üíî';
          }

          this.container.appendChild(heart);
        }
      }

      loseLife(lifeIndex) {
        const hearts = this.container.querySelectorAll('.heart');
        const heart = hearts[lifeIndex];

        heart.classList.add('breaking');
        setTimeout(() => {
          heart.classList.remove('active');
          heart.classList.add('lost');
          heart.innerHTML = 'üíî';
          heart.classList.remove('breaking');
        }, 500);
      }
    }

    // ============================================
    // STREAK COUNTER COMPONENT
    // ============================================

    class StreakCounter {
      constructor(container) {
        this.container = container;
        this.streak = 0;
        this.init();
      }

      init() {
        this.container.innerHTML = `
          <div class="streak-container">
            <div class="streak-emoji" id="streak-emoji">üî•</div>
            <div class="streak-count" id="streak-count">0</div>
          </div>
        `;
      }

      update(newStreak) {
        const oldStreak = this.streak;
        this.streak = newStreak;

        const countEl = document.getElementById('streak-count');
        const emojiEl = document.getElementById('streak-emoji');

        countEl.textContent = newStreak;

        if (newStreak > oldStreak) {
          emojiEl.classList.add('streak-grow');
          countEl.classList.add('streak-increment');

          setTimeout(() => {
            emojiEl.classList.remove('streak-grow');
            countEl.classList.remove('streak-increment');
          }, 300);

          if (newStreak % 5 === 0 && newStreak > 0) {
            this.celebrate();
          }
        } else if (newStreak === 0 && oldStreak > 0) {
          emojiEl.classList.add('streak-reset');
          countEl.classList.add('streak-reset');

          setTimeout(() => {
            emojiEl.classList.remove('streak-reset');
            countEl.classList.remove('streak-reset');
          }, 500);
        }
      }

      celebrate() {
        for (let i = 0; i < 8; i++) {
          const sparkle = document.createElement('div');
          sparkle.className = 'streak-sparkle';
          sparkle.textContent = '‚ú®';
          sparkle.style.setProperty('--angle', `${i * 45}deg`);
          this.container.appendChild(sparkle);

          setTimeout(() => sparkle.remove(), 1000);
        }
      }
    }

    // ============================================
    // CONSTANTS
    // ============================================

    const COLORS = {
      thumb: { name: 'red', hex: '#FF5757' },
      index: { name: 'yellow', hex: '#FFD700' },
      middle: { name: 'green', hex: '#4CAF50' },
      ring: { name: 'blue', hex: '#2196F3' },
      pinky: { name: 'purple', hex: '#9C27B0' }
    };

    const FINGER_TIPS = {
      thumb: 4,
      index: 8,
      middle: 12,
      ring: 16,
      pinky: 20
    };

    const FINGER_NAMES = ['thumb', 'index', 'middle', 'ring', 'pinky'];
    const COLOR_NAMES = ['red', 'yellow', 'green', 'blue', 'purple'];

    const TARGET_CONFIG = {
      width: 140,
      height: 90,
      cornerRadius: 20,
      borderWidth: 3
    };

    const CAMERA_FRAME_CONFIG = {
      maxWidthRatio: 0.88,
      maxHeightRatio: 0.78,
      minPaddingX: 24,
      minPaddingY: 90,
      aspect: 16 / 9,
      cornerRadius: 28,
      borderWidth: 2
    };

    const CONFIG = {
      touchHoldTime: 300,
      sequenceShowTime: 500,
      memorizePause: 300,
      minConfidence: 0.6,
      smoothFactor: 0.5,
      scaleBaseWidth: 150
    };

    const GAME_STATES = {
      IDLE: 'idle',
      SHOW_SEQUENCE: 'showing',
      REPLAY: 'replay',
      SUCCESS: 'success',
      GAME_OVER: 'game_over'
    };

    // ============================================
    // GAME STATE
    // ============================================

    let gameState = {
      phase: GAME_STATES.IDLE,
      currentSequence: [],
      userInput: [],
      sequenceIndex: 0,
      round: 0,
      highScore: parseInt(localStorage.getItem('colorMemoryHighScore') || '0'),
      totalTouches: 0,
      isNewHighScore: false,
      lives: 3,
      maxLives: 3,
      streak: 0
    };

    let handState = {
      detected: false,
      landmarks: null,
      smoothedLandmarks: null,
      palmCenter: null,
      palmWidth: 0,
      scaleFactor: 1,
      fingerStates: {},
      observability: 'unobservable',
      confidence: 0
    };

    let touchState = {
      activeFinger: null,
      touchStartTime: null,
      inTouchZone: false,
      cooldown: false,
      registered: false
    };

    let targetState = {
      state: 'waiting',
      shakeOffset: 0
    };

    let cameraFrame = {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      radius: CAMERA_FRAME_CONFIG.cornerRadius
    };

    // ============================================
    // DOM ELEMENTS
    // ============================================

    const bgCanvas = document.getElementById('bg-canvas');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const video = document.getElementById('video');

    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const tutorialOverlay = document.getElementById('tutorial-overlay');
    const warningBanner = document.getElementById('warning-banner');
    const bestScoreDisplay = document.getElementById('best-score');

    // UI Components
    let livesDisplay, streakCounter, progressBar, nebula;

    // ============================================
    // AUDIO
    // ============================================

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    function playTone(frequency, duration, type = 'sine', volume = 0.3) {
      try {
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        oscillator.frequency.value = frequency;
        oscillator.type = type;
        gainNode.gain.value = volume;

        const now = audioCtx.currentTime;
        oscillator.start(now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + duration / 1000);
        oscillator.stop(now + duration / 1000);
      } catch (e) {
        console.warn('Audio error:', e);
      }
    }

    function playSuccess() {
      playTone(523, 150, 'sine', 0.4);
      setTimeout(() => playTone(659, 150, 'sine', 0.4), 150);
      setTimeout(() => playTone(784, 150, 'sine', 0.4), 300);
    }

    function playError() {
      playTone(200, 200, 'sine', 0.2);
    }

    function playSequenceTone(colorIndex) {
      const frequencies = [262, 330, 392, 523, 659];
      playTone(frequencies[colorIndex % frequencies.length], 150, 'triangle', 0.3);
    }

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================

    function dist(a, b) {
      return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
    }

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function toPx(landmark, width, height) {
      const frame = cameraFrame.width ? cameraFrame : { x: 0, y: 0, width, height };
      return {
        x: frame.x + landmark.x * frame.width,
        y: frame.y + landmark.y * frame.height,
        z: landmark.z
      };
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function roundedRectPath(ctx, x, y, width, height, radius) {
      const safeRadius = Math.min(radius, width / 2, height / 2);
      ctx.beginPath();
      ctx.moveTo(x + safeRadius, y);
      ctx.lineTo(x + width - safeRadius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + safeRadius);
      ctx.lineTo(x + width, y + height - safeRadius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - safeRadius, y + height);
      ctx.lineTo(x + safeRadius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - safeRadius);
      ctx.lineTo(x, y + safeRadius);
      ctx.quadraticCurveTo(x, y, x + safeRadius, y);
      ctx.closePath();
    }

    function updateCameraFrame(width, height) {
      const paddingX = Math.max(CAMERA_FRAME_CONFIG.minPaddingX, width * (1 - CAMERA_FRAME_CONFIG.maxWidthRatio) / 2);
      const paddingY = Math.max(CAMERA_FRAME_CONFIG.minPaddingY, height * (1 - CAMERA_FRAME_CONFIG.maxHeightRatio) / 2);
      const maxWidth = Math.max(0, width - paddingX * 2);
      const maxHeight = Math.max(0, height - paddingY * 2);

      let frameWidth = maxWidth;
      let frameHeight = frameWidth / CAMERA_FRAME_CONFIG.aspect;
      if (frameHeight > maxHeight) {
        frameHeight = maxHeight;
        frameWidth = frameHeight * CAMERA_FRAME_CONFIG.aspect;
      }

      cameraFrame = {
        x: (width - frameWidth) / 2,
        y: (height - frameHeight) / 2,
        width: frameWidth,
        height: frameHeight,
        radius: Math.min(CAMERA_FRAME_CONFIG.cornerRadius, frameWidth / 8, frameHeight / 6)
      };
    }

    // ============================================
    // HAND TRACKING ENGINES
    // ============================================

    function updateScaleNormalization(landmarks, width, height) {
      if (!landmarks) return;

      const indexMCP = toPx(landmarks[5], width, height);
      const pinkyMCP = toPx(landmarks[17], width, height);

      handState.palmWidth = dist(indexMCP, pinkyMCP);
      handState.scaleFactor = handState.palmWidth / CONFIG.scaleBaseWidth;
      handState.scaleFactor = Math.max(0.5, Math.min(2.0, handState.scaleFactor));
    }

    function calculatePalmCenter(landmarks, width, height) {
      if (!landmarks) return null;

      const wrist = toPx(landmarks[0], width, height);
      const indexMCP = toPx(landmarks[5], width, height);
      const pinkyMCP = toPx(landmarks[17], width, height);
      const middleMCP = toPx(landmarks[9], width, height);

      return {
        x: (wrist.x + indexMCP.x + pinkyMCP.x + middleMCP.x) / 4,
        y: (wrist.y + indexMCP.y + pinkyMCP.y + middleMCP.y) / 4
      };
    }

    function updateObservationThresholds(landmarks, width, height) {
      if (!landmarks) {
        handState.observability = 'unobservable';
        handState.fingerStates = {};
        return;
      }

      const fingerStates = {};
      let totalConfidence = 0;

      for (const [name, tipIndex] of Object.entries(FINGER_TIPS)) {
        const tip = toPx(landmarks[tipIndex], width, height);
        const mcp = toPx(landmarks[tipIndex - 3], width, height);

        let confidence = 1.0;

        const edgeMargin = 50;
        const frameLeft = cameraFrame.x;
        const frameRight = cameraFrame.x + cameraFrame.width;
        const frameTop = cameraFrame.y;
        const frameBottom = cameraFrame.y + cameraFrame.height;
        if (tip.x < frameLeft + edgeMargin || tip.x > frameRight - edgeMargin ||
            tip.y < frameTop + edgeMargin || tip.y > frameBottom - edgeMargin) {
          confidence *= 0.7;
        }

        if (tip.z > 0.1) confidence *= 0.8;

        const extensionDist = dist(tip, mcp);
        const palmScale = handState.palmWidth || 100;
        const extensionRatio = extensionDist / palmScale;

        fingerStates[name] = {
          confidence,
          extended: extensionRatio > 0.5,
          position: tip,
          state: confidence > 0.7 ? 'observed' : confidence > 0.4 ? 'less' : 'unobservable'
        };

        totalConfidence += confidence;
      }

      handState.fingerStates = fingerStates;
      handState.confidence = totalConfidence / 5;
      handState.observability = handState.confidence > 0.7 ? 'observed' :
                                handState.confidence > 0.4 ? 'less' : 'unobservable';
    }

    function isFingerExtended(landmarks, fingerName, width, height) {
      const tipIndex = FINGER_TIPS[fingerName];
      const pipIndex = tipIndex - 2;
      const mcpIndex = tipIndex - 3;

      const tip = toPx(landmarks[tipIndex], width, height);
      const pip = toPx(landmarks[pipIndex], width, height);
      const mcp = toPx(landmarks[mcpIndex], width, height);

      const tipToPip = dist(tip, pip);
      const pipToMcp = dist(pip, mcp);
      const tipToMcp = dist(tip, mcp);

      const extensionRatio = tipToMcp / (handState.palmWidth || 100);
      const straightness = tipToMcp / (tipToPip + pipToMcp);

      return extensionRatio > 0.6 && straightness > 0.85;
    }

    // ============================================
    // TOUCH DETECTION
    // ============================================

    function detectRectangularTouch(landmarks, width, height) {
      if (!landmarks || !handState.palmCenter) return null;

      const palmCenter = handState.palmCenter;
      const scaledWidth = TARGET_CONFIG.width * handState.scaleFactor;
      const scaledHeight = TARGET_CONFIG.height * handState.scaleFactor;

      const boxLeft = palmCenter.x - scaledWidth / 2;
      const boxRight = palmCenter.x + scaledWidth / 2;
      const boxTop = palmCenter.y - scaledHeight / 2;
      const boxBottom = palmCenter.y + scaledHeight / 2;

      for (const [name, tipIndex] of Object.entries(FINGER_TIPS)) {
        const fingerState = handState.fingerStates[name];

        if (!fingerState || fingerState.state === 'unobservable') continue;

        const tip = toPx(landmarks[tipIndex], width, height);

        if (tip.x >= boxLeft && tip.x <= boxRight &&
            tip.y >= boxTop && tip.y <= boxBottom) {

          const isBent = !isFingerExtended(landmarks, name, width, height);
          if (isBent || name === 'thumb') {
            return { finger: name, position: tip };
          }
        }
      }

      return null;
    }

    function processTouchInput(touchData, now) {
      if (touchState.cooldown) return;

      if (touchData) {
        if (touchState.activeFinger === touchData.finger) {
          const holdTime = now - touchState.touchStartTime;

          if (holdTime >= CONFIG.touchHoldTime && !touchState.registered) {
            touchState.registered = true;
            handleValidTouch(touchData.finger);
          }
        } else {
          touchState.activeFinger = touchData.finger;
          touchState.touchStartTime = now;
          touchState.registered = false;
          touchState.inTouchZone = true;
        }
      } else {
        if (touchState.inTouchZone) {
          touchState.inTouchZone = false;
          touchState.activeFinger = null;
          touchState.registered = false;
        }
      }
    }

    function handleValidTouch(finger) {
      if (gameState.phase !== GAME_STATES.REPLAY) return;

      const expectedColor = gameState.currentSequence[gameState.sequenceIndex];
      const fingerColor = COLORS[finger].name;

      if (fingerColor === expectedColor) {
        // CORRECT TOUCH
        targetState.state = 'correct';
        playSuccess();
        gameState.userInput.push(fingerColor);
        gameState.sequenceIndex++;
        gameState.totalTouches++;
        gameState.streak++;

        updateProgressBar();
        streakCounter.update(gameState.streak);

        if (gameState.sequenceIndex >= gameState.currentSequence.length) {
          setTimeout(() => roundSuccess(), 400);
        } else {
          setTimeout(() => {
            targetState.state = 'waiting';
          }, 300);
        }

        touchState.cooldown = true;
        setTimeout(() => { touchState.cooldown = false; }, 400);

      } else {
        // WRONG TOUCH - LOSE A LIFE
        gameState.lives--;
        gameState.streak = 0;

        playError();
        shakeTarget(15, 400);
        targetState.state = 'error';

        livesDisplay.loseLife(gameState.lives);
        streakCounter.update(0);

        if (gameState.lives <= 0) {
          setTimeout(() => gameOver(), 600);
        } else {
          setTimeout(() => {
            targetState.state = 'waiting';
          }, 800);

          touchState.cooldown = true;
          setTimeout(() => { touchState.cooldown = false; }, 800);
        }
      }
    }

    // ============================================
    // GAME FLOW
    // ============================================

    function startGame() {
      tutorialOverlay.classList.add('hidden');
      startScreen.classList.add('hidden');
      gameOverScreen.classList.add('hidden');

      gameState = {
        phase: GAME_STATES.SHOW_SEQUENCE,
        currentSequence: [],
        userInput: [],
        sequenceIndex: 0,
        round: 0,
        highScore: parseInt(localStorage.getItem('colorMemoryHighScore') || '0'),
        totalTouches: 0,
        isNewHighScore: false,
        lives: 3,
        maxLives: 3,
        streak: 0
      };

      bestScoreDisplay.textContent = gameState.highScore;
      targetState.state = 'waiting';

      // Initialize components
      livesDisplay.render(gameState.lives, gameState.maxLives);
      streakCounter.update(0);

      nextRound();
    }

    function nextRound() {
      gameState.round++;
      gameState.userInput = [];
      gameState.sequenceIndex = 0;

      if (gameState.round === 1) {
        gameState.currentSequence = [randomColor()];
      } else {
        gameState.currentSequence.push(randomColor());
      }

      progressBar.reset(gameState.currentSequence.length);
      showSequence();
    }

    function randomColor() {
      return COLOR_NAMES[Math.floor(Math.random() * COLOR_NAMES.length)];
    }

    async function showSequence() {
      gameState.phase = GAME_STATES.SHOW_SEQUENCE;

      for (let i = 0; i < gameState.currentSequence.length; i++) {
        await sleep(200);
        playSequenceTone(COLOR_NAMES.indexOf(gameState.currentSequence[i]));
        await sleep(CONFIG.sequenceShowTime);
      }

      await sleep(CONFIG.memorizePause);
      startReplay();
    }

    function startReplay() {
      gameState.phase = GAME_STATES.REPLAY;
      gameState.sequenceIndex = 0;

      targetState.state = 'waiting';

      touchState = {
        activeFinger: null,
        touchStartTime: null,
        inTouchZone: false,
        lastTouchTime: 0,
        cooldown: false,
        registered: false
      };
    }

    function roundSuccess() {
      gameState.phase = GAME_STATES.SUCCESS;

      if (gameState.round > gameState.highScore) {
        gameState.highScore = gameState.round;
        gameState.isNewHighScore = true;
        localStorage.setItem('colorMemoryHighScore', gameState.highScore.toString());
        bestScoreDisplay.textContent = gameState.highScore;
        bestScoreDisplay.classList.add('celebrating');
        setTimeout(() => bestScoreDisplay.classList.remove('celebrating'), 500);
        spawnConfetti(20);
      }

      setTimeout(() => nextRound(), 1500);
    }

    function gameOver() {
      gameState.phase = GAME_STATES.GAME_OVER;

      document.getElementById('final-round').textContent = gameState.round;
      document.getElementById('final-touches').textContent = gameState.totalTouches;

      const newHighScoreEl = document.getElementById('new-high-score');
      if (gameState.isNewHighScore) {
        newHighScoreEl.classList.remove('hidden');
      } else {
        newHighScoreEl.classList.add('hidden');
      }

      gameOverScreen.classList.remove('hidden');
    }

    function updateProgressBar() {
      progressBar.update(gameState.sequenceIndex);
    }

    function spawnConfetti(count) {
      const colors = ['#FF5757', '#FFD700', '#4CAF50', '#2196F3', '#9C27B0'];
      const container = document.getElementById('confetti-container');

      for (let i = 0; i < count; i++) {
        const particle = document.createElement('div');
        particle.className = 'confetti-particle';
        particle.style.left = `${Math.random() * 100}%`;
        particle.style.background = colors[Math.floor(Math.random() * colors.length)];
        particle.style.animationDelay = `${Math.random() * 0.5}s`;
        container.appendChild(particle);

        setTimeout(() => particle.remove(), 3000);
      }
    }

    function shakeTarget(intensity, duration) {
      const startTime = Date.now();

      function animate() {
        const elapsed = Date.now() - startTime;
        const progress = elapsed / duration;

        if (progress < 1) {
          const dampedIntensity = intensity * (1 - progress);
          targetState.shakeOffset = dampedIntensity * Math.sin(progress * Math.PI * 8);
          requestAnimationFrame(animate);
        } else {
          targetState.shakeOffset = 0;
        }
      }

      requestAnimationFrame(animate);
    }

    // ============================================
    // RENDERING
    // ============================================

    function render(landmarks, width, height) {
      ctx.clearRect(0, 0, width, height);
      drawCameraFrame();

      if (!landmarks) return;

      const palmCenter = handState.palmCenter;
      const scaledWidth = TARGET_CONFIG.width * handState.scaleFactor;
      const scaledHeight = TARGET_CONFIG.height * handState.scaleFactor;

      // Draw target zone (rounded rectangle)
      if (palmCenter && gameState.phase === GAME_STATES.REPLAY) {
        drawTargetZone(ctx, palmCenter, scaledWidth, scaledHeight, targetState.state);
      }

      // Draw finger indicators
      for (const [name, tipIndex] of Object.entries(FINGER_TIPS)) {
        const tip = toPx(landmarks[tipIndex], width, height);
        const color = COLORS[name];

        // Finger dot
        ctx.fillStyle = color.hex;
        ctx.beginPath();
        ctx.arc(tip.x, tip.y, 12, 0, Math.PI * 2);
        ctx.fill();

        // Glow for active finger
        if (touchState.activeFinger === name && touchState.inTouchZone) {
          ctx.strokeStyle = color.hex;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(tip.x, tip.y, 20, 0, Math.PI * 2);
          ctx.stroke();

          // Progress ring
          if (touchState.touchStartTime) {
            const progress = Math.min(1, (Date.now() - touchState.touchStartTime) / CONFIG.touchHoldTime);
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(tip.x, tip.y, 25, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);
            ctx.stroke();
          }
        }
      }

      // Draw skeleton
      drawSkeleton(landmarks, width, height);
    }

    function drawCameraFrame() {
      if (!cameraFrame.width || !cameraFrame.height) return;

      ctx.save();
      roundedRectPath(ctx, cameraFrame.x, cameraFrame.y, cameraFrame.width, cameraFrame.height, cameraFrame.radius);
      ctx.fillStyle = 'rgba(13, 13, 26, 0.55)';
      ctx.fill();
      ctx.clip();
      ctx.drawImage(video, cameraFrame.x, cameraFrame.y, cameraFrame.width, cameraFrame.height);
      ctx.restore();

      ctx.save();
      roundedRectPath(ctx, cameraFrame.x, cameraFrame.y, cameraFrame.width, cameraFrame.height, cameraFrame.radius);
      ctx.strokeStyle = 'rgba(138, 43, 226, 0.6)';
      ctx.lineWidth = CAMERA_FRAME_CONFIG.borderWidth;
      ctx.shadowBlur = 18;
      ctx.shadowColor = 'rgba(0, 229, 255, 0.25)';
      ctx.stroke();
      ctx.restore();
    }

    function drawTargetZone(ctx, palmCenter, scaledWidth, scaledHeight, state) {
      const x = palmCenter.x - scaledWidth / 2 + targetState.shakeOffset;
      const y = palmCenter.y - scaledHeight / 2;
      const radius = TARGET_CONFIG.cornerRadius;

      // Pulse animation
      let scale = 1.0;
      if (state === 'waiting') {
        const t = (Date.now() % 2000) / 2000;
        scale = 1.0 + 0.08 * Math.sin(t * Math.PI * 2);
      }

      ctx.save();
      ctx.translate(palmCenter.x, palmCenter.y);
      ctx.scale(scale, scale);
      ctx.translate(-palmCenter.x, -palmCenter.y);

      // Draw rounded rectangle
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + scaledWidth - radius, y);
      ctx.quadraticCurveTo(x + scaledWidth, y, x + scaledWidth, y + radius);
      ctx.lineTo(x + scaledWidth, y + scaledHeight - radius);
      ctx.quadraticCurveTo(x + scaledWidth, y + scaledHeight, x + scaledWidth - radius, y + scaledHeight);
      ctx.lineTo(x + radius, y + scaledHeight);
      ctx.quadraticCurveTo(x, y + scaledHeight, x, y + scaledHeight - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();

      if (state === 'waiting') {
        ctx.shadowBlur = 20;
        ctx.shadowColor = 'rgba(0, 229, 255, 0.6)';
        ctx.strokeStyle = 'rgba(0, 229, 255, 0.8)';
        ctx.lineWidth = TARGET_CONFIG.borderWidth;
        ctx.stroke();
        ctx.shadowBlur = 0;
      } else if (state === 'correct') {
        ctx.fillStyle = 'rgba(0, 229, 255, 0.4)';
        ctx.fill();
        ctx.shadowBlur = 30;
        ctx.shadowColor = 'rgba(0, 229, 255, 1)';
        ctx.strokeStyle = 'rgba(0, 229, 255, 1)';
        ctx.lineWidth = TARGET_CONFIG.borderWidth;
        ctx.stroke();
        ctx.shadowBlur = 0;
      } else if (state === 'error') {
        ctx.shadowBlur = 20;
        ctx.shadowColor = 'rgba(255, 20, 147, 0.8)';
        ctx.strokeStyle = 'rgba(255, 20, 147, 1)';
        ctx.lineWidth = TARGET_CONFIG.borderWidth;
        ctx.stroke();
        ctx.shadowBlur = 0;
      }

      ctx.restore();
    }

    function drawSkeleton(landmarks, width, height) {
      const connections = [
        [0, 1], [1, 2], [2, 3], [3, 4],
        [0, 5], [5, 6], [6, 7], [7, 8],
        [0, 9], [9, 10], [10, 11], [11, 12],
        [0, 13], [13, 14], [14, 15], [15, 16],
        [0, 17], [17, 18], [18, 19], [19, 20],
        [5, 9], [9, 13], [13, 17]
      ];

      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.lineWidth = 2;

      for (const [i, j] of connections) {
        const a = toPx(landmarks[i], width, height);
        const b = toPx(landmarks[j], width, height);

        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      }
    }

    function smoothLandmarks(newLandmarks) {
      if (!handState.smoothedLandmarks) {
        handState.smoothedLandmarks = JSON.parse(JSON.stringify(newLandmarks));
        return handState.smoothedLandmarks;
      }

      for (let i = 0; i < newLandmarks.length; i++) {
        handState.smoothedLandmarks[i].x = lerp(
          handState.smoothedLandmarks[i].x,
          newLandmarks[i].x,
          CONFIG.smoothFactor
        );
        handState.smoothedLandmarks[i].y = lerp(
          handState.smoothedLandmarks[i].y,
          newLandmarks[i].y,
          CONFIG.smoothFactor
        );
        handState.smoothedLandmarks[i].z = lerp(
          handState.smoothedLandmarks[i].z,
          newLandmarks[i].z,
          CONFIG.smoothFactor
        );
      }

      return handState.smoothedLandmarks;
    }

    // ============================================
    // MEDIAPIPE INTEGRATION
    // ============================================

    function onResults(results) {
      const width = canvas.width;
      const height = canvas.height;

      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const rawLandmarks = results.multiHandLandmarks[0];
        const landmarks = smoothLandmarks(rawLandmarks);

        handState.detected = true;
        handState.landmarks = landmarks;

        updateScaleNormalization(landmarks, width, height);
        handState.palmCenter = calculatePalmCenter(landmarks, width, height);
        updateObservationThresholds(landmarks, width, height);

        if (gameState.phase === GAME_STATES.REPLAY) {
          const touchData = detectRectangularTouch(landmarks, width, height);
          processTouchInput(touchData, Date.now());
        }

        render(landmarks, width, height);

      } else {
        handState.detected = false;
        handState.landmarks = null;
        handState.smoothedLandmarks = null;

        ctx.clearRect(0, 0, width, height);
        drawCameraFrame();
      }

      updateTrackingStatus();
    }

    function updateTrackingStatus() {
      if (!handState.detected || handState.observability === 'unobservable') {
        warningBanner.classList.add('show');
      } else {
        warningBanner.classList.remove('show');
      }
    }

    // ============================================
    // INITIALIZATION
    // ============================================

    async function init() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      bgCanvas.width = window.innerWidth;
      bgCanvas.height = window.innerHeight;
      updateCameraFrame(canvas.width, canvas.height);

      // Initialize background
      nebula = new NebulaBackground(bgCanvas);
      nebula.init();

      // Background animation loop (30fps)
      let lastBgUpdate = 0;
      function bgLoop(timestamp) {
        if (timestamp - lastBgUpdate >= 33) { // ~30fps
          nebula.render();
          lastBgUpdate = timestamp;
        }
        requestAnimationFrame(bgLoop);
      }
      requestAnimationFrame(bgLoop);

      // Initialize UI components
      livesDisplay = new LivesDisplay(document.getElementById('lives-display'));
      streakCounter = new StreakCounter(document.getElementById('streak-display'));
      progressBar = new ProgressBar(document.getElementById('progress-container'), 1);

      bestScoreDisplay.textContent = gameState.highScore;

      // MediaPipe Hands
      const hands = new Hands({
        locateFile: (file) => {
          return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }
      });

      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: CONFIG.minConfidence,
        minTrackingConfidence: CONFIG.minConfidence
      });

      hands.onResults(onResults);

      const camera = new Camera(video, {
        onFrame: async () => {
          await hands.send({ image: video });
        },
        width: 1280,
        height: 720
      });

      await camera.start();

      window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        bgCanvas.width = window.innerWidth;
        bgCanvas.height = window.innerHeight;
        updateCameraFrame(canvas.width, canvas.height);
      });
    }

    // ============================================
    // NAVIGATION
    // ============================================

    function goBack() {
      window.location.href = 'index.html';
    }

    function closeTutorial() {
      tutorialOverlay.classList.add('hidden');
    }

    // ============================================
    // START
    // ============================================

    init().catch(console.error);
  </script>
</body>
</html>
