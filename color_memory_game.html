<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Color Memory Touch - HandHero</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <style>
    :root {
      /* Light Theme (Default - Wordle Style) */
      --bg-light: #FFFFFF;
      --text-primary-light: #212121;
      --text-secondary-light: #787C7E;

      /* Dark Theme */
      --bg-dark: #121213;
      --text-primary-dark: #F8FAFC;
      --text-secondary-dark: #A0A4A8;

      /* Wordle Feedback Colors */
      --wordle-correct: #6AAA64;
      --wordle-present: #C9B458;
      --wordle-absent: #787C7E;
      --wordle-border: #D3D6DA;
      --wordle-border-dark: #3A3A3C;

      /* Finger Colors (High Contrast) */
      --red: #FF5757;
      --yellow: #FFD700;
      --green: #4CAF50;
      --blue: #2196F3;
      --purple: #9C27B0;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif;
      font-size: 16px;
      line-height: 1.6;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
      transition: background-color 0.3s, color 0.3s;
    }

    /* Light theme (default) */
    body[data-theme="light"] {
      background: var(--bg-light);
      color: var(--text-primary-light);
      --bg: var(--bg-light);
      --text-primary: var(--text-primary-light);
      --text-secondary: var(--text-secondary-light);
      --tile-border: var(--wordle-border);
      --tile-border-dark: transparent;
    }

    /* Dark theme */
    body[data-theme="dark"] {
      background: var(--bg-dark);
      color: var(--text-primary-dark);
      --bg: var(--bg-dark);
      --text-primary: var(--text-primary-dark);
      --text-secondary: var(--text-secondary-dark);
      --tile-border: var(--wordle-border-dark);
      --tile-border-dark: var(--wordle-border);
    }

    /* Canvas container */
    #canvas-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    #video {
      display: none;
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transform: scaleX(-1);
    }

    /* UI Overlay */
    .ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }

    .ui-overlay > * {
      pointer-events: auto;
    }

    /* Top Bar */
    .top-bar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 60px;
      background: var(--bg);
      border-bottom: 1px solid var(--tile-border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      z-index: 100;
    }

    .top-bar-left {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .icon-btn {
      width: 40px;
      height: 40px;
      border: none;
      background: transparent;
      font-size: 22px;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .icon-btn:hover {
      background: var(--tile-border);
    }

    /* Sequence indicator */
    .sequence-indicator {
      display: flex;
      gap: 6px;
      align-items: center;
      flex: 1;
      justify-content: center;
    }

    .seq-dot {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--tile-border);
      transition: all 0.3s ease;
      opacity: 0.5;
    }

    .seq-dot.active {
      transform: scale(1.3);
      opacity: 1;
    }

    .seq-dot.completed {
      opacity: 0.8;
    }

    /* Best score display */
    .best-score {
      text-align: right;
      min-width: 80px;
    }

    .score-label {
      font-size: 11px;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .score-value {
      font-size: 32px;
      font-weight: 700;
      color: var(--wordle-correct);
    }

    .score-value.celebrating {
      animation: celebrate 0.5s ease;
    }

    @keyframes celebrate {
      0%, 100% { transform: scale(1); }
      25% { transform: scale(1.2); }
      50% { transform: scale(1.1); }
      75% { transform: scale(1.15); }
    }

    /* Floating instruction */
    .floating-instruction {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg);
      border: 1px solid var(--tile-border);
      border-radius: 12px;
      padding: 12px 24px;
      font-size: 16px;
      color: var(--text-primary);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      animation: slideDown 0.3s ease, fadeOut 0.5s ease 2.5s forwards;
      z-index: 50;
      white-space: nowrap;
    }

    @keyframes slideDown {
      from { opacity: 0; transform: translate(-50%, -20px); }
      to { opacity: 1; transform: translate(-50%, 0); }
    }

    @keyframes fadeOut {
      to { opacity: 0; pointer-events: none; }
    }

    .instruction-dot {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin: 0 4px;
      vertical-align: middle;
    }

    /* Game center area */
    .game-center {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 20;
    }

    /* Game screens */
    .game-screen {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 16px;
      padding: 40px 60px;
      text-align: center;
      animation: fadeIn 0.5s ease;
      max-width: 500px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.2);
    }

    body[data-theme="dark"] .game-screen {
      background: rgba(18, 18, 19, 0.95);
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.9); }
      to { opacity: 1; transform: scale(1); }
    }

    .game-screen h1 {
      font-size: 36px;
      font-weight: 700;
      margin-bottom: 16px;
      background: linear-gradient(135deg, var(--red), var(--yellow), var(--green), var(--blue), var(--purple));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .game-screen p {
      color: var(--text-secondary);
      font-size: 16px;
      margin-bottom: 24px;
      max-width: 400px;
    }

    .game-btn {
      background: var(--wordle-correct);
      border: none;
      border-radius: 8px;
      padding: 12px 32px;
      color: white;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      margin: 8px;
    }

    .game-btn:hover {
      background: #5a9a54;
      transform: translateY(-2px);
    }

    .game-btn.secondary {
      background: transparent;
      border: 1px solid var(--tile-border);
      color: var(--text-primary);
    }

    .game-btn.secondary:hover {
      background: var(--tile-border);
      color: var(--text-primary);
    }

    /* Game over stats */
    .game-over-stats {
      display: flex;
      justify-content: center;
      gap: 40px;
      margin: 24px 0;
    }

    .stat-item {
      text-align: center;
    }

    .stat-value {
      font-size: 36px;
      font-weight: 700;
      color: var(--wordle-correct);
    }

    .stat-label {
      font-size: 12px;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .new-high-score {
      color: var(--wordle-present);
      font-size: 20px;
      font-weight: 600;
      margin-top: 16px;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* Tutorial overlay */
    .tutorial-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 200;
      animation: fadeIn 0.3s ease;
    }

    .tutorial-content {
      background: var(--bg);
      border-radius: 16px;
      padding: 40px;
      max-width: 500px;
      text-align: center;
      border: 1px solid var(--tile-border);
    }

    .tutorial-content h2 {
      font-size: 28px;
      margin-bottom: 20px;
    }

    .tutorial-fingers {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin: 30px 0;
    }

    .tutorial-finger {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    .tutorial-finger .dot {
      width: 36px;
      height: 36px;
      border-radius: 50%;
    }

    .tutorial-finger .name {
      font-size: 12px;
      color: var(--text-secondary);
    }

    /* Warning banner */
    .warning-banner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 193, 7, 0.1);
      border: 2px solid var(--wordle-present);
      border-radius: 16px;
      padding: 20px 40px;
      text-align: center;
      display: none;
      z-index: 15;
      color: var(--wordle-present);
    }

    .warning-banner.show {
      display: block;
      animation: fadeIn 0.3s ease;
    }

    /* Confetti container */
    #confetti-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1000;
    }

    .confetti-particle {
      position: fixed;
      width: 10px;
      height: 10px;
      top: -10px;
      border-radius: 2px;
      pointer-events: none;
      animation: confettiFall 3s ease-out forwards;
    }

    @keyframes confettiFall {
      to {
        transform: translateY(100vh) rotate(720deg);
        opacity: 0;
      }
    }

    /* Hidden state */
    .hidden {
      display: none !important;
    }
  </style>
</head>
<body data-theme="light">
  <div id="canvas-container">
    <video id="video" playsinline></video>
    <canvas id="canvas"></canvas>

    <div class="ui-overlay">
      <!-- Top Bar -->
      <div class="top-bar">
        <div class="top-bar-left">
          <button class="icon-btn home" onclick="goBack()" title="Back to menu">üè†</button>
          <button class="icon-btn theme-toggle" onclick="toggleTheme()" title="Toggle dark mode">
            <span id="theme-icon">üåô</span>
          </button>
        </div>

        <div class="sequence-indicator" id="sequence-indicator"></div>

        <div class="best-score">
          <div class="score-label">Best</div>
          <div class="score-value" id="best-score">0</div>
        </div>
      </div>

      <!-- Floating instruction -->
      <div class="floating-instruction hidden" id="instruction"></div>

      <!-- Game center area -->
      <div class="game-center" id="game-center">
        <!-- Start screen -->
        <div class="game-screen" id="start-screen">
          <h1>Color Memory Touch</h1>
          <p>Watch the colored tiles, then touch your palm with the matching finger. Build the longest sequence!</p>
          <button class="game-btn" onclick="startGame()">Start Game</button>
        </div>

        <!-- Game over screen -->
        <div class="game-screen hidden" id="game-over-screen">
          <h1>Game Over!</h1>
          <div class="game-over-stats">
            <div class="stat-item">
              <div class="stat-value" id="final-round">0</div>
              <div class="stat-label">Sequence Length</div>
            </div>
            <div class="stat-item">
              <div class="stat-value" id="final-touches">0</div>
              <div class="stat-label">Correct Touches</div>
            </div>
          </div>
          <div class="new-high-score hidden" id="new-high-score">üéâ New High Score!</div>
          <button class="game-btn" onclick="startGame()">Play Again</button>
          <button class="game-btn secondary" onclick="goBack()">Back to Menu</button>
        </div>
      </div>

      <!-- Warning banner -->
      <div class="warning-banner" id="warning-banner">
        ‚ö†Ô∏è Hand not detected - improve lighting or hand position
      </div>
    </div>

    <!-- Tutorial overlay -->
    <div class="tutorial-overlay hidden" id="tutorial-overlay">
      <div class="tutorial-content">
        <h2>How to Play</h2>
        <p>Each finger has a color. Watch the sequence light up, then touch your palm center with the correct fingers in order.</p>
        <div class="tutorial-fingers">
          <div class="tutorial-finger">
            <div class="dot" style="background: var(--red)"></div>
            <div class="name">Thumb</div>
          </div>
          <div class="tutorial-finger">
            <div class="dot" style="background: var(--yellow)"></div>
            <div class="name">Index</div>
          </div>
          <div class="tutorial-finger">
            <div class="dot" style="background: var(--green)"></div>
            <div class="name">Middle</div>
          </div>
          <div class="tutorial-finger">
            <div class="dot" style="background: var(--blue)"></div>
            <div class="name">Ring</div>
          </div>
          <div class="tutorial-finger">
            <div class="dot" style="background: var(--purple)"></div>
            <div class="name">Pinky</div>
          </div>
        </div>
        <p><strong>Tip:</strong> Hold your fingertip on the target for 0.3 seconds to register a touch.</p>
        <button class="game-btn" onclick="closeTutorial()" style="margin-top: 20px;">Let's Play!</button>
      </div>
    </div>

    <!-- Confetti container -->
    <div id="confetti-container"></div>
  </div>

  <script>
    // ============================================
    // CONSTANTS & CONFIGURATION
    // ============================================

    const COLORS = {
      thumb: { name: 'red', hex: '#FF5757' },
      index: { name: 'yellow', hex: '#FFD700' },
      middle: { name: 'green', hex: '#4CAF50' },
      ring: { name: 'blue', hex: '#2196F3' },
      pinky: { name: 'purple', hex: '#9C27B0' }
    };

    const FINGER_TIPS = {
      thumb: 4,
      index: 8,
      middle: 12,
      ring: 16,
      pinky: 20
    };

    const FINGER_NAMES = ['thumb', 'index', 'middle', 'ring', 'pinky'];
    const COLOR_NAMES = ['red', 'yellow', 'green', 'blue', 'purple'];

    const TARGET_CONFIG = {
      width: 80,
      height: 50,
      cornerRadius: 20,
      borderWidth: 3
    };

    const CONFIG = {
      touchHoldTime: 300,
      sequenceShowTime: 500,
      memorizePause: 300,
      targetAppearTime: 300,
      minConfidence: 0.6,
      smoothFactor: 0.5,
      scaleBaseWidth: 150
    };

    const GAME_STATES = {
      IDLE: 'idle',
      SHOW_SEQUENCE: 'showing',
      MEMORIZE: 'memorizing',
      REPLAY: 'replay',
      SUCCESS: 'success',
      GAME_OVER: 'game_over'
    };

    // ============================================
    // GAME STATE
    // ============================================

    let gameState = {
      phase: GAME_STATES.IDLE,
      currentSequence: [],
      userInput: [],
      sequenceIndex: 0,
      round: 0,
      highScore: parseInt(localStorage.getItem('colorMemoryHighScore') || '0'),
      totalTouches: 0,
      isNewHighScore: false
    };

    // ============================================
    // HAND TRACKING STATE
    // ============================================

    let handState = {
      detected: false,
      landmarks: null,
      smoothedLandmarks: null,
      palmCenter: null,
      palmWidth: 0,
      scaleFactor: 1,
      fingerStates: {},
      observability: 'unobservable',
      confidence: 0
    };

    // Touch detection state
    let touchState = {
      activeFinger: null,
      touchStartTime: null,
      inTouchZone: false,
      lastTouchTime: 0,
      cooldown: false,
      registered: false
    };

    // Target zone state
    let targetState = {
      state: 'waiting', // waiting, approaching, correct, error
      shakeOffset: 0
    };

    // ============================================
    // DOM ELEMENTS
    // ============================================

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const video = document.getElementById('video');

    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const tutorialOverlay = document.getElementById('tutorial-overlay');
    const warningBanner = document.getElementById('warning-banner');
    const sequenceIndicator = document.getElementById('sequence-indicator');
    const instruction = document.getElementById('instruction');
    const bestScoreDisplay = document.getElementById('best-score');
    const themeIcon = document.getElementById('theme-icon');

    // ============================================
    // THEME SYSTEM
    // ============================================

    let isDarkMode = localStorage.getItem('darkMode') === 'true';

    function toggleTheme() {
      isDarkMode = !isDarkMode;
      localStorage.setItem('darkMode', isDarkMode);
      applyTheme();
    }

    function applyTheme() {
      document.body.dataset.theme = isDarkMode ? 'dark' : 'light';
      themeIcon.textContent = isDarkMode ? '‚òÄÔ∏è' : 'üåô';
    }

    // Apply theme on load
    applyTheme();

    // ============================================
    // AUDIO (Web Audio API)
    // ============================================

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let soundEnabled = localStorage.getItem('soundEnabled') !== 'false';

    function playTone(frequency, duration, type = 'sine', volume = 0.3) {
      if (!soundEnabled) return;

      try {
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        oscillator.frequency.value = frequency;
        oscillator.type = type;
        gainNode.gain.value = volume;

        const now = audioCtx.currentTime;
        oscillator.start(now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + duration / 1000);
        oscillator.stop(now + duration / 1000);
      } catch (e) {
        console.warn('Audio error:', e);
      }
    }

    function playSuccess() {
      playTone(523, 150, 'sine', 0.4);
      setTimeout(() => playTone(659, 150, 'sine', 0.4), 150);
      setTimeout(() => playTone(784, 150, 'sine', 0.4), 300);
    }

    function playError() {
      playTone(200, 200, 'sine', 0.2);
    }

    function playSequenceTone(colorIndex) {
      const frequencies = [262, 330, 392, 523, 659];
      playTone(frequencies[colorIndex % frequencies.length], 150, 'triangle', 0.3);
    }

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================

    function dist(a, b) {
      return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
    }

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function toPx(landmark, width, height) {
      return {
        x: landmark.x * width,
        y: landmark.y * height,
        z: landmark.z
      };
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // ============================================
    // SCALE NORMALIZATION ENGINE
    // ============================================

    function updateScaleNormalization(landmarks, width, height) {
      if (!landmarks) return;

      const indexMCP = toPx(landmarks[5], width, height);
      const pinkyMCP = toPx(landmarks[17], width, height);

      handState.palmWidth = dist(indexMCP, pinkyMCP);
      handState.scaleFactor = handState.palmWidth / CONFIG.scaleBaseWidth;
      handState.scaleFactor = Math.max(0.5, Math.min(2.0, handState.scaleFactor));
    }

    // ============================================
    // PALM CENTER DETECTION
    // ============================================

    function calculatePalmCenter(landmarks, width, height) {
      if (!landmarks) return null;

      const wrist = toPx(landmarks[0], width, height);
      const indexMCP = toPx(landmarks[5], width, height);
      const pinkyMCP = toPx(landmarks[17], width, height);
      const middleMCP = toPx(landmarks[9], width, height);

      return {
        x: (wrist.x + indexMCP.x + pinkyMCP.x + middleMCP.x) / 4,
        y: (wrist.y + indexMCP.y + pinkyMCP.y + middleMCP.y) / 4
      };
    }

    // ============================================
    // OBSERVATION THRESHOLDS ENGINE
    // ============================================

    function updateObservationThresholds(landmarks, width, height) {
      if (!landmarks) {
        handState.observability = 'unobservable';
        handState.fingerStates = {};
        return;
      }

      const fingerStates = {};
      let totalConfidence = 0;

      for (const [name, tipIndex] of Object.entries(FINGER_TIPS)) {
        const tip = toPx(landmarks[tipIndex], width, height);
        const mcp = toPx(landmarks[tipIndex - 3], width, height);

        let confidence = 1.0;

        const edgeMargin = 50;
        if (tip.x < edgeMargin || tip.x > width - edgeMargin ||
            tip.y < edgeMargin || tip.y > height - edgeMargin) {
          confidence *= 0.7;
        }

        if (tip.z > 0.1) confidence *= 0.8;

        const extensionDist = dist(tip, mcp);
        const palmScale = handState.palmWidth || 100;
        const extensionRatio = extensionDist / palmScale;

        fingerStates[name] = {
          confidence,
          extended: extensionRatio > 0.5,
          position: tip,
          state: confidence > 0.7 ? 'observed' : confidence > 0.4 ? 'less' : 'unobservable'
        };

        totalConfidence += confidence;
      }

      handState.fingerStates = fingerStates;
      handState.confidence = totalConfidence / 5;
      handState.observability = handState.confidence > 0.7 ? 'observed' :
                                handState.confidence > 0.4 ? 'less' : 'unobservable';
    }

    // ============================================
    // FINGER EXTENSION DETECTION
    // ============================================

    function isFingerExtended(landmarks, fingerName, width, height) {
      const tipIndex = FINGER_TIPS[fingerName];
      const pipIndex = tipIndex - 2;
      const mcpIndex = tipIndex - 3;

      const tip = toPx(landmarks[tipIndex], width, height);
      const pip = toPx(landmarks[pipIndex], width, height);
      const mcp = toPx(landmarks[mcpIndex], width, height);

      const tipToPip = dist(tip, pip);
      const pipToMcp = dist(pip, mcp);
      const tipToMcp = dist(tip, mcp);

      const extensionRatio = tipToMcp / (handState.palmWidth || 100);
      const straightness = tipToMcp / (tipToPip + pipToMcp);

      return extensionRatio > 0.6 && straightness > 0.85;
    }

    // ============================================
    // TOUCH DETECTION (ROUNDED RECTANGLE)
    // ============================================

    function detectRectangularTouch(landmarks, width, height) {
      if (!landmarks || !handState.palmCenter) return null;

      const palmCenter = handState.palmCenter;
      const scaledWidth = TARGET_CONFIG.width * handState.scaleFactor;
      const scaledHeight = TARGET_CONFIG.height * handState.scaleFactor;

      const boxLeft = palmCenter.x - scaledWidth / 2;
      const boxRight = palmCenter.x + scaledWidth / 2;
      const boxTop = palmCenter.y - scaledHeight / 2;
      const boxBottom = palmCenter.y + scaledHeight / 2;

      for (const [name, tipIndex] of Object.entries(FINGER_TIPS)) {
        const fingerState = handState.fingerStates[name];

        if (!fingerState || fingerState.state === 'unobservable') continue;

        const tip = toPx(landmarks[tipIndex], width, height);

        if (tip.x >= boxLeft && tip.x <= boxRight &&
            tip.y >= boxTop && tip.y <= boxBottom) {

          const isBent = !isFingerExtended(landmarks, name, width, height);
          if (isBent || name === 'thumb') {
            return { finger: name, position: tip };
          }
        }
      }

      return null;
    }

    function processTouchInput(touchData, now) {
      if (touchState.cooldown) return;

      if (touchData) {
        if (touchState.activeFinger === touchData.finger) {
          const holdTime = now - touchState.touchStartTime;

          if (holdTime >= CONFIG.touchHoldTime && !touchState.registered) {
            touchState.registered = true;
            handleValidTouch(touchData.finger);
          }
        } else {
          touchState.activeFinger = touchData.finger;
          touchState.touchStartTime = now;
          touchState.registered = false;
          touchState.inTouchZone = true;
        }
      } else {
        if (touchState.inTouchZone) {
          touchState.inTouchZone = false;
          touchState.activeFinger = null;
          touchState.registered = false;
        }
      }
    }

    function handleValidTouch(finger) {
      if (gameState.phase !== GAME_STATES.REPLAY) return;

      const expectedColor = gameState.currentSequence[gameState.sequenceIndex];
      const fingerColor = COLORS[finger].name;

      if (fingerColor === expectedColor) {
        targetState.state = 'correct';
        playSuccess();
        gameState.userInput.push(fingerColor);
        gameState.sequenceIndex++;
        gameState.totalTouches++;

        updateSequenceIndicator();

        if (gameState.sequenceIndex >= gameState.currentSequence.length) {
          setTimeout(() => roundSuccess(), 400);
        } else {
          setTimeout(() => {
            targetState.state = 'waiting';
          }, 300);
        }

        touchState.cooldown = true;
        setTimeout(() => { touchState.cooldown = false; }, 400);

      } else {
        playError();
        shakeTarget(15, 400);
        targetState.state = 'error';
        setTimeout(() => gameOver(), 600);
      }
    }

    // ============================================
    // GAME FLOW FUNCTIONS
    // ============================================

    function startGame() {
      tutorialOverlay.classList.add('hidden');
      startScreen.classList.add('hidden');
      gameOverScreen.classList.add('hidden');

      gameState = {
        phase: GAME_STATES.SHOW_SEQUENCE,
        currentSequence: [],
        userInput: [],
        sequenceIndex: 0,
        round: 0,
        highScore: parseInt(localStorage.getItem('colorMemoryHighScore') || '0'),
        totalTouches: 0,
        isNewHighScore: false
      };

      bestScoreDisplay.textContent = gameState.highScore;
      targetState.state = 'waiting';

      nextRound();
    }

    function nextRound() {
      gameState.round++;
      gameState.userInput = [];
      gameState.sequenceIndex = 0;

      if (gameState.round === 1) {
        gameState.currentSequence = [randomColor()];
      } else {
        gameState.currentSequence.push(randomColor());
      }

      updateSequenceIndicator();
      showSequence();
    }

    function randomColor() {
      return COLOR_NAMES[Math.floor(Math.random() * COLOR_NAMES.length)];
    }

    async function showSequence() {
      gameState.phase = GAME_STATES.SHOW_SEQUENCE;
      showInstruction(`Watch the sequence light up...`, -1);

      // Build sequence indicator with empty tiles
      updateSequenceIndicator();

      // Show each color
      for (let i = 0; i < gameState.currentSequence.length; i++) {
        await sleep(200);
        highlightSequenceIndicator(i);
        playSequenceTone(COLOR_NAMES.indexOf(gameState.currentSequence[i]));
        await sleep(CONFIG.sequenceShowTime);
      }

      // Memorize pause
      await sleep(CONFIG.memorizePause);

      startReplay();
    }

    function startReplay() {
      gameState.phase = GAME_STATES.REPLAY;
      gameState.sequenceIndex = 0;

      const nextColor = gameState.currentSequence[0];
      const fingerName = Object.keys(COLORS).find(k => COLORS[k].name === nextColor);
      const dotHtml = `<span class="instruction-dot" style="background: ${COLORS[fingerName].hex}"></span>`;
      showInstruction(`Touch ${dotHtml} ${nextColor.charAt(0).toUpperCase() + nextColor.slice(1)} to target`, 3000);

      targetState.state = 'waiting';

      touchState = {
        activeFinger: null,
        touchStartTime: null,
        inTouchZone: false,
        lastTouchTime: 0,
        cooldown: false,
        registered: false
      };
    }

    function roundSuccess() {
      gameState.phase = GAME_STATES.SUCCESS;

      if (gameState.round > gameState.highScore) {
        gameState.highScore = gameState.round;
        gameState.isNewHighScore = true;
        localStorage.setItem('colorMemoryHighScore', gameState.highScore.toString());
        bestScoreDisplay.textContent = gameState.highScore;
        bestScoreDisplay.classList.add('celebrating');
        setTimeout(() => bestScoreDisplay.classList.remove('celebrating'), 500);
        spawnConfetti(15);
      }

      showInstruction(`Great! Sequence was ${gameState.round} colors long`, 2000);

      setTimeout(() => nextRound(), 1500);
    }

    function gameOver() {
      gameState.phase = GAME_STATES.GAME_OVER;

      document.getElementById('final-round').textContent = gameState.round;
      document.getElementById('final-touches').textContent = gameState.totalTouches;

      const newHighScoreEl = document.getElementById('new-high-score');
      if (gameState.isNewHighScore) {
        newHighScoreEl.classList.remove('hidden');
      } else {
        newHighScoreEl.classList.add('hidden');
      }

      gameOverScreen.classList.remove('hidden');
    }

    // ============================================
    // UI UPDATE FUNCTIONS
    // ============================================

    function updateSequenceIndicator() {
      sequenceIndicator.innerHTML = '';

      for (let i = 0; i < gameState.currentSequence.length; i++) {
        const dot = document.createElement('div');
        dot.className = 'seq-dot';
        dot.id = `seq-dot-${i}`;
        dot.style.background = COLORS[getFingerFromColor(gameState.currentSequence[i])].hex;

        if (i < gameState.sequenceIndex) {
          dot.classList.add('completed');
        }

        sequenceIndicator.appendChild(dot);
      }
    }

    function highlightSequenceIndicator(index) {
      const dot = document.getElementById(`seq-dot-${index}`);
      if (dot) {
        dot.classList.add('active');
      }
    }

    function getFingerFromColor(colorName) {
      for (const [finger, color] of Object.entries(COLORS)) {
        if (color.name === colorName) return finger;
      }
      return 'thumb';
    }

    function showInstruction(text, duration) {
      instruction.innerHTML = text;
      instruction.classList.remove('hidden');

      if (duration > 0) {
        setTimeout(() => {
          instruction.classList.add('hidden');
        }, duration);
      }
    }

    function updateTrackingStatus() {
      if (!handState.detected) {
        warningBanner.classList.add('show');
      } else if (handState.observability === 'unobservable') {
        warningBanner.classList.add('show');
      } else {
        warningBanner.classList.remove('show');
      }
    }

    function spawnConfetti(count) {
      const colors = [COLORS.thumb.hex, COLORS.index.hex, COLORS.middle.hex, COLORS.ring.hex, COLORS.pinky.hex];
      const container = document.getElementById('confetti-container');

      for (let i = 0; i < count; i++) {
        const particle = document.createElement('div');
        particle.className = 'confetti-particle';
        particle.style.left = `${Math.random() * 100}%`;
        particle.style.background = colors[Math.floor(Math.random() * colors.length)];
        particle.style.animationDelay = `${Math.random() * 0.5}s`;
        container.appendChild(particle);

        setTimeout(() => particle.remove(), 3000);
      }
    }

    // ============================================
    // RENDERING
    // ============================================

    function render(landmarks, width, height) {
      ctx.clearRect(0, 0, width, height);
      ctx.drawImage(video, 0, 0, width, height);

      if (!landmarks) return;

      const palmCenter = handState.palmCenter;
      const scaledWidth = TARGET_CONFIG.width * handState.scaleFactor;
      const scaledHeight = TARGET_CONFIG.height * handState.scaleFactor;

      // Draw target zone (rounded rectangle)
      if (palmCenter && gameState.phase === GAME_STATES.REPLAY) {
        drawTargetZone(ctx, palmCenter, scaledWidth, scaledHeight, targetState.state);
      }

      // Draw finger indicators
      for (const [name, tipIndex] of Object.entries(FINGER_TIPS)) {
        const tip = toPx(landmarks[tipIndex], width, height);
        const color = COLORS[name];
        const fingerState = handState.fingerStates[name];

        // Finger dot
        ctx.fillStyle = color.hex;
        ctx.beginPath();
        ctx.arc(tip.x, tip.y, 12, 0, Math.PI * 2);
        ctx.fill();

        // Glow for active finger
        if (touchState.activeFinger === name && touchState.inTouchZone) {
          ctx.strokeStyle = color.hex;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(tip.x, tip.y, 20, 0, Math.PI * 2);
          ctx.stroke();

          // Progress ring
          if (touchState.touchStartTime) {
            const progress = Math.min(1, (Date.now() - touchState.touchStartTime) / CONFIG.touchHoldTime);
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(tip.x, tip.y, 25, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);
            ctx.stroke();
          }
        }
      }

      // Draw skeleton
      drawSkeleton(landmarks, width, height);
    }

    function drawTargetZone(ctx, palmCenter, scaledWidth, scaledHeight, state) {
      const x = palmCenter.x - scaledWidth / 2 + targetState.shakeOffset;
      const y = palmCenter.y - scaledHeight / 2;
      const radius = TARGET_CONFIG.cornerRadius;

      // Pulse animation for waiting state
      let scale = 1.0;
      if (state === 'waiting') {
        const t = (Date.now() % 2000) / 2000;
        scale = 1.0 + 0.05 * Math.sin(t * Math.PI * 2);
      }

      ctx.save();
      ctx.translate(palmCenter.x, palmCenter.y);
      ctx.scale(scale, scale);
      ctx.translate(-palmCenter.x, -palmCenter.y);

      // Draw rounded rectangle
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + scaledWidth - radius, y);
      ctx.quadraticCurveTo(x + scaledWidth, y, x + scaledWidth, y + radius);
      ctx.lineTo(x + scaledWidth, y + scaledHeight - radius);
      ctx.quadraticCurveTo(x + scaledWidth, y + scaledHeight, x + scaledWidth - radius, y + scaledHeight);
      ctx.lineTo(x + radius, y + scaledHeight);
      ctx.quadraticCurveTo(x, y + scaledHeight, x, y + scaledHeight - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();

      if (state === 'waiting') {
        ctx.strokeStyle = 'rgba(211, 214, 218, 0.6)';
        ctx.lineWidth = TARGET_CONFIG.borderWidth;
        ctx.stroke();
      } else if (state === 'approaching') {
        ctx.strokeStyle = '#C9B458';
        ctx.fillStyle = 'rgba(201, 180, 88, 0.1)';
        ctx.lineWidth = TARGET_CONFIG.borderWidth;
        ctx.fill();
        ctx.stroke();
      } else if (state === 'correct') {
        ctx.fillStyle = '#6AAA64';
        ctx.fill();
      } else if (state === 'error') {
        ctx.strokeStyle = '#FF5757';
        ctx.lineWidth = TARGET_CONFIG.borderWidth;
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawSkeleton(landmarks, width, height) {
      const connections = [
        [0, 1], [1, 2], [2, 3], [3, 4],
        [0, 5], [5, 6], [6, 7], [7, 8],
        [0, 9], [9, 10], [10, 11], [11, 12],
        [0, 13], [13, 14], [14, 15], [15, 16],
        [0, 17], [17, 18], [18, 19], [19, 20],
        [5, 9], [9, 13], [13, 17]
      ];

      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.lineWidth = 2;

      for (const [i, j] of connections) {
        const a = toPx(landmarks[i], width, height);
        const b = toPx(landmarks[j], width, height);

        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      }
    }

    function shakeTarget(intensity, duration) {
      const startTime = Date.now();

      function animate() {
        const elapsed = Date.now() - startTime;
        const progress = elapsed / duration;

        if (progress < 1) {
          const dampedIntensity = intensity * (1 - progress);
          targetState.shakeOffset = dampedIntensity * Math.sin(progress * Math.PI * 8);
          requestAnimationFrame(animate);
        } else {
          targetState.shakeOffset = 0;
        }
      }

      requestAnimationFrame(animate);
    }

    // ============================================
    // LANDMARK SMOOTHING
    // ============================================

    function smoothLandmarks(newLandmarks) {
      if (!handState.smoothedLandmarks) {
        handState.smoothedLandmarks = JSON.parse(JSON.stringify(newLandmarks));
        return handState.smoothedLandmarks;
      }

      for (let i = 0; i < newLandmarks.length; i++) {
        handState.smoothedLandmarks[i].x = lerp(
          handState.smoothedLandmarks[i].x,
          newLandmarks[i].x,
          CONFIG.smoothFactor
        );
        handState.smoothedLandmarks[i].y = lerp(
          handState.smoothedLandmarks[i].y,
          newLandmarks[i].y,
          CONFIG.smoothFactor
        );
        handState.smoothedLandmarks[i].z = lerp(
          handState.smoothedLandmarks[i].z,
          newLandmarks[i].z,
          CONFIG.smoothFactor
        );
      }

      return handState.smoothedLandmarks;
    }

    // ============================================
    // MEDIAPIPE INTEGRATION
    // ============================================

    function onResults(results) {
      const width = canvas.width;
      const height = canvas.height;

      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const rawLandmarks = results.multiHandLandmarks[0];
        const landmarks = smoothLandmarks(rawLandmarks);

        handState.detected = true;
        handState.landmarks = landmarks;

        updateScaleNormalization(landmarks, width, height);
        handState.palmCenter = calculatePalmCenter(landmarks, width, height);
        updateObservationThresholds(landmarks, width, height);

        if (gameState.phase === GAME_STATES.REPLAY) {
          const touchData = detectRectangularTouch(landmarks, width, height);
          processTouchInput(touchData, Date.now());
        }

        render(landmarks, width, height);

      } else {
        handState.detected = false;
        handState.landmarks = null;
        handState.smoothedLandmarks = null;

        ctx.clearRect(0, 0, width, height);
        ctx.drawImage(video, 0, 0, width, height);
      }

      updateTrackingStatus();
    }

    // ============================================
    // INITIALIZATION
    // ============================================

    async function init() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      const hands = new Hands({
        locateFile: (file) => {
          return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }
      });

      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: CONFIG.minConfidence,
        minTrackingConfidence: CONFIG.minConfidence
      });

      hands.onResults(onResults);

      const camera = new Camera(video, {
        onFrame: async () => {
          await hands.send({ image: video });
        },
        width: 1280,
        height: 720
      });

      await camera.start();

      bestScoreDisplay.textContent = gameState.highScore;

      window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      });
    }

    // ============================================
    // NAVIGATION
    // ============================================

    function goBack() {
      window.location.href = 'index.html';
    }

    function closeTutorial() {
      tutorialOverlay.classList.add('hidden');
    }

    // ============================================
    // START
    // ============================================

    init().catch(console.error);
  </script>
</body>
</html>
