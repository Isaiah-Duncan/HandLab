<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HandHero – Invisible Boundary Beta (Visible Debug)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:rgba(255,255,255,0.08);
      --panel2:rgba(255,255,255,0.12);
      --text:rgba(255,255,255,0.92);
      --muted:rgba(255,255,255,0.66);
      --good:rgba(34,197,94,0.95);
      --ok:rgba(59,130,246,0.95);
      --low:rgba(109,40,217,0.9);
      --bad:rgba(239,68,68,0.92);
      --line:rgba(255,255,255,0.22);
    }
    html,body{height:100%;margin:0;background:radial-gradient(1200px 700px at 70% 20%, rgba(76, 110, 245, 0.18), transparent 55%),
      radial-gradient(1000px 700px at 20% 70%, rgba(34, 197, 94, 0.16), transparent 60%),
      var(--bg);
      color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    }
    .wrap{display:grid;grid-template-columns:1fr 340px;gap:16px;height:100%;padding:16px;box-sizing:border-box;}
    .stage{position:relative;border-radius:18px;overflow:hidden;background:#000;box-shadow:0 20px 60px rgba(0,0,0,0.45);}
    video{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;transform:scaleX(-1);} /* mirror */
    canvas{position:absolute;inset:0;width:100%;height:100%;}

    .side{display:flex;flex-direction:column;gap:12px;}
    .card{background:var(--panel);border:1px solid rgba(255,255,255,0.14);backdrop-filter:blur(10px);border-radius:16px;padding:14px;}
    .row{display:flex;align-items:center;justify-content:space-between;gap:10px;}
    .title{font-weight:700;letter-spacing:0.2px;}
    .muted{color:var(--muted);font-size:12px;line-height:1.35;}
    .pill{display:inline-flex;align-items:center;gap:8px;padding:8px 10px;border-radius:999px;background:var(--panel2);border:1px solid rgba(255,255,255,0.14);}
    .dot{width:10px;height:10px;border-radius:999px;background:var(--line);}
    .dot.good{background:var(--good);} .dot.ok{background:var(--ok);} .dot.low{background:var(--low);} .dot.bad{background:var(--bad);} 

    button, select, input[type="range"]{font:inherit;}
    button{
      cursor:pointer;border:1px solid rgba(255,255,255,0.16);background:rgba(255,255,255,0.10);
      color:var(--text);border-radius:12px;padding:10px 12px;font-weight:650;
    }
    button:hover{background:rgba(255,255,255,0.14);} 
    button:active{transform:translateY(1px);} 

    .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
    select{width:100%;border-radius:12px;padding:10px 12px;border:1px solid rgba(255,255,255,0.16);background:rgba(0,0,0,0.25);color:var(--text);}
    .kv{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center;}
    .kv label{font-size:12px;color:var(--muted);} 
    .kv .val{font-variant-numeric:tabular-nums;}
    input[type="range"]{width:100%;}

    .legend{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px;}
    .legend .pill{padding:6px 9px;}

    .footer{margin-top:auto}

    @media (max-width: 980px){
      .wrap{grid-template-columns:1fr;}
      .side{order:-1;}
      .stage{height:60vh;}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="stage" id="stage">
      <video id="video" playsinline></video>
      <canvas id="canvas"></canvas>
    </div>

    <div class="side">
      <div class="card">
        <div class="row">
          <div>
            <div class="title">Invisible Boundary Beta (Visible Debug)</div>
            <div class="muted">This is a focused sandbox to test boundary logic. It draws the boundaries and zones directly on top of the MediaPipe hand skeleton.</div>
          </div>
        </div>
        <div class="legend">
          <span class="pill"><span class="dot good"></span><span class="muted">Green boundary + safe band</span></span>
          <span class="pill"><span class="dot ok"></span><span class="muted">Blue boundary + acceptable band</span></span>
          <span class="pill"><span class="dot low"></span><span class="muted">Purple boundary + low band</span></span>
          <span class="pill"><span class="dot bad"></span><span class="muted">Red thumb line</span></span>
        </div>
      </div>

      <div class="card">
        <div class="grid">
          <button id="btnStart">Start camera</button>
          <button id="btnPause">Pause</button>
        </div>
        <div style="height:10px"></div>
        <div class="grid">
          <button id="btnToggleIBE">IBE: ON</button>
          <button id="btnToggleOverlay">Overlay: ON</button>
        </div>
        <div style="height:12px"></div>
        <div class="kv">
          <label for="mode">Test mode</label>
          <select id="mode">
            <option value="open">Open Hand (all fingers)</option>
            <option value="scout">Scout Salute (index+middle+ring)</option>
            <option value="pinch_tp">Pinch: Thumb → Pinky</option>
            <option value="pinch_ti">Pinch: Thumb → Index</option>
          </select>
        </div>
        <div style="height:10px"></div>
        <div class="kv">
          <label>Boundary spacing (px)</label>
          <div class="val" id="spacingVal">26</div>
        </div>
        <input id="spacing" type="range" min="10" max="60" step="1" value="26" />

        <div style="height:10px"></div>
        <div class="kv">
          <label>Band opacity</label>
          <div class="val" id="opacityVal">0.22</div>
        </div>
        <input id="opacity" type="range" min="0.05" max="0.45" step="0.01" value="0.22" />

        <div style="height:10px"></div>
        <div class="kv">
          <label>Skeleton smoothing (0–0.95)</label>
          <div class="val" id="smoothVal">0.65</div>
        </div>
        <input id="smooth" type="range" min="0" max="0.95" step="0.01" value="0.65" />

        <div style="height:12px"></div>
        <div class="pill" style="width:100%;justify-content:space-between">
          <span class="muted">Status</span>
          <span id="status" style="font-weight:700">Idle</span>
        </div>
        <div style="height:10px"></div>
        <div class="pill" style="width:100%;justify-content:space-between">
          <span class="muted">Zone</span>
          <span id="zone" style="font-weight:800">—</span>
        </div>
        <div style="height:10px"></div>
        <div class="muted" id="debug">Waiting for camera…</div>
      </div>

      <div class="card footer">
        <div class="muted">
          Notes:
          <ul>
            <li>This file loads MediaPipe Hands via CDN.</li>
            <li>Video is mirrored; the canvas overlay is mirrored the same way so boundaries align visually.</li>
            <li>Boundary math here is a <em>beta scaffold</em>. You can swap in your full InvisibleBoundaryEngine evaluate() later.</li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <!-- MediaPipe Hands (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

  <script>
    // ========= UI / State =========
    const state = {
      running: false,
      paused: false,
      ibeEnabled: true,
      overlayEnabled: true,
      mode: 'open',
      spacingPx: 26,
      bandOpacity: 0.22,
      smooth: 0.65,
    };

    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    const statusEl = document.getElementById('status');
    const zoneEl = document.getElementById('zone');
    const debugEl = document.getElementById('debug');

    const btnStart = document.getElementById('btnStart');
    const btnPause = document.getElementById('btnPause');
    const btnToggleIBE = document.getElementById('btnToggleIBE');
    const btnToggleOverlay = document.getElementById('btnToggleOverlay');
    const modeSel = document.getElementById('mode');

    const spacing = document.getElementById('spacing');
    const spacingVal = document.getElementById('spacingVal');
    const opacity = document.getElementById('opacity');
    const opacityVal = document.getElementById('opacityVal');
    const smooth = document.getElementById('smooth');
    const smoothVal = document.getElementById('smoothVal');

    function setStatus(t){ statusEl.textContent = t; }
    function setZone(text, css){ zoneEl.textContent = text; zoneEl.style.color = css || 'var(--text)'; }

    btnStart.onclick = () => start();
    btnPause.onclick = () => {
      state.paused = !state.paused;
      btnPause.textContent = state.paused ? 'Resume' : 'Pause';
      setStatus(state.paused ? 'Paused' : 'Running');
    };

    btnToggleIBE.onclick = () => {
      state.ibeEnabled = !state.ibeEnabled;
      btnToggleIBE.textContent = `IBE: ${state.ibeEnabled ? 'ON' : 'OFF'}`;
    };

    btnToggleOverlay.onclick = () => {
      state.overlayEnabled = !state.overlayEnabled;
      btnToggleOverlay.textContent = `Overlay: ${state.overlayEnabled ? 'ON' : 'OFF'}`;
    };

    modeSel.onchange = (e) => state.mode = e.target.value;

    spacing.oninput = (e) => {
      state.spacingPx = Number(e.target.value);
      spacingVal.textContent = String(state.spacingPx);
    };

    opacity.oninput = (e) => {
      state.bandOpacity = Number(e.target.value);
      opacityVal.textContent = state.bandOpacity.toFixed(2);
    };

    smooth.oninput = (e) => {
      state.smooth = Number(e.target.value);
      smoothVal.textContent = state.smooth.toFixed(2);
    };

    // ========= MediaPipe Setup =========
    let hands, camera;

    function resizeCanvas(){
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.round(rect.width * devicePixelRatio);
      canvas.height = Math.round(rect.height * devicePixelRatio);
      ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    }

    window.addEventListener('resize', resizeCanvas);

    async function start(){
      if (state.running) return;
      resizeCanvas();

      hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
      });
      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6,
      });
      hands.onResults(onResults);

      camera = new Camera(video, {
        onFrame: async () => {
          if (!state.paused) {
            await hands.send({ image: video });
          }
        },
        width: 1280,
        height: 720,
      });

      try {
        await camera.start();
        state.running = true;
        setStatus('Running');
        debugEl.textContent = 'Camera started. Show your hand.';
      } catch (e){
        setStatus('Camera error');
        debugEl.textContent = String(e);
      }
    }

    // ========= Smoothing =========
    let smoothed = null;

    function smoothLandmarks(lm){
      if (!lm) return null;
      const a = state.smooth;
      if (!smoothed || smoothed.length !== lm.length){
        smoothed = lm.map(p => ({x:p.x, y:p.y, z:p.z}));
        return smoothed;
      }
      for (let i=0;i<lm.length;i++){
        smoothed[i].x = smoothed[i].x * a + lm[i].x * (1-a);
        smoothed[i].y = smoothed[i].y * a + lm[i].y * (1-a);
        smoothed[i].z = smoothed[i].z * a + lm[i].z * (1-a);
      }
      return smoothed;
    }

    // ========= Boundary Beta Math =========
    // This is a simplified visible-boundary scaffold.
    // It generates 3 parallel lines anchored to a chosen segment on the hand.

    const TIP = { thumb:4, index:8, middle:12, ring:16, pinky:20 };

    function pickAnchor(lm){
      // Return an anchor segment (two points) and a normal direction.
      // We use index+middle MCPs to define an axis, then normal is perpendicular.
      // MCPs: index=5, middle=9, ring=13, pinky=17
      const pA = lm[9];  // middle MCP
      const pB = lm[5];  // index MCP
      return { a: pA, b: pB };
    }

    function toPx(p){
      // mirrored video: x must be flipped for overlay to match
      const x = (1 - p.x) * canvas.getBoundingClientRect().width;
      const y = p.y * canvas.getBoundingClientRect().height;
      return { x, y };
    }

    function lineFromPoints(aPx, bPx){
      const dx = bPx.x - aPx.x;
      const dy = bPx.y - aPx.y;
      const len = Math.hypot(dx, dy) || 1;
      const ux = dx / len;
      const uy = dy / len;
      // normal (perp)
      const nx = -uy;
      const ny = ux;
      return { a:aPx, b:bPx, ux, uy, nx, ny };
    }

    function offsetLine(L, offset){
      return {
        a: { x: L.a.x + L.nx * offset, y: L.a.y + L.ny * offset },
        b: { x: L.b.x + L.nx * offset, y: L.b.y + L.ny * offset },
      };
    }

    function distPointToLine(px, a, b){
      // Signed distance to infinite line (a->b)
      const dx = b.x - a.x, dy = b.y - a.y;
      const num = (px.x - a.x) * dy - (px.y - a.y) * dx;
      const den = Math.hypot(dx, dy) || 1;
      return num / den;
    }

    function evaluateZone(lm){
      const anchor = pickAnchor(lm);
      const aPx = toPx(anchor.a);
      const bPx = toPx(anchor.b);
      const base = lineFromPoints(aPx, bPx);

      const s = state.spacingPx;
      // Tune offsets so lines sit across the upper palm like your wireframe.
      const green = offsetLine(base, -s * 0.25);
      const acceptable = offsetLine(base, +s * 1.0);
      const low = offsetLine(base, +s * 2.0);

      // Use "non-target" average tip distance as a crude metric.
      const tips = getModeTips(lm);
      const nonTargets = tips.nonTargets;
      const pts = nonTargets.map(i => toPx(lm[i]));
      const meanSigned = pts.reduce((acc,p)=>acc+distPointToLine(p, green.a, green.b), 0) / Math.max(1, pts.length);

      // Interpret: below green is safe; between green/acceptable is acceptable; above acceptable is low.
      let zone = 'SAFE', color = 'var(--good)';
      if (meanSigned > 0 && meanSigned < distPointToLine({x:0,y:0}, acceptable.a, acceptable.b)) {
        zone = 'ACCEPTABLE'; color = 'var(--ok)';
      }
      // Better: compare meanSigned to distances relative to green using line normals
      // We'll use thresholds in px against green line.
      const t1 = s * 0.9;
      const t2 = s * 1.9;
      if (meanSigned > t1) { zone = 'ACCEPTABLE'; color='var(--ok)'; }
      if (meanSigned > t2) { zone = 'LOW'; color='var(--low)'; }

      return { green, acceptable, low, meanSigned, zone, color };
    }

    function getModeTips(lm){
      // Returns which fingers should be measured (targets) vs nonTargets for the boundary logic.
      // This beta is about visualizing the bands; you can refine target mapping later.
      let targets = [];
      if (state.mode === 'open') targets = [TIP.thumb, TIP.index, TIP.middle, TIP.ring, TIP.pinky];
      if (state.mode === 'scout') targets = [TIP.index, TIP.middle, TIP.ring];
      if (state.mode === 'pinch_tp') targets = [TIP.thumb, TIP.pinky];
      if (state.mode === 'pinch_ti') targets = [TIP.thumb, TIP.index];

      const all = [TIP.thumb, TIP.index, TIP.middle, TIP.ring, TIP.pinky];
      const nonTargets = all.filter(t => !targets.includes(t));
      return { targets, nonTargets };
    }

    // ========= Drawing =========

    function drawLine(line, color, width=5, dashed=true){
      ctx.save();
      ctx.lineWidth = width;
      ctx.strokeStyle = color;
      ctx.lineCap = 'round';
      if (dashed) ctx.setLineDash([10,8]);
      ctx.beginPath();
      ctx.moveTo(line.a.x, line.a.y);
      ctx.lineTo(line.b.x, line.b.y);
      ctx.stroke();
      ctx.restore();
    }

    function fillBetween(top, bottom, rgba){
      ctx.save();
      ctx.fillStyle = rgba;
      ctx.beginPath();
      ctx.moveTo(top.a.x, top.a.y);
      ctx.lineTo(top.b.x, top.b.y);
      ctx.lineTo(bottom.b.x, bottom.b.y);
      ctx.lineTo(bottom.a.x, bottom.a.y);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function fillCapAbove(line, rgba){
      const w = canvas.getBoundingClientRect().width;
      ctx.save();
      ctx.fillStyle = rgba;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(w, 0);
      ctx.lineTo(line.b.x, line.b.y);
      ctx.lineTo(line.a.x, line.a.y);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawThumbRed(lm){
      const wrist = toPx(lm[0]);
      const tip = toPx(lm[4]);
      const mcp = toPx(lm[2]);
      const dx = tip.x - mcp.x;
      const dy = tip.y - mcp.y;
      const len = Math.hypot(dx,dy) || 1;
      const ex = (dx/len)*90;
      const ey = (dy/len)*90;

      ctx.save();
      ctx.lineWidth = 6;
      ctx.strokeStyle = 'var(--bad)';
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(wrist.x, wrist.y);
      ctx.lineTo(tip.x + ex, tip.y + ey);
      ctx.stroke();

      ctx.globalAlpha = 0.18;
      ctx.fillStyle = 'var(--bad)';
      ctx.beginPath();
      ctx.moveTo(wrist.x, wrist.y);
      ctx.lineTo(tip.x + ex, tip.y + ey);
      ctx.lineTo(tip.x + ex + 40, tip.y + ey + 40);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    function drawSkeleton(lm){
      // Draw landmarks + connections using MediaPipe drawing utils
      drawConnectors(ctx, lm, HAND_CONNECTIONS, {color:'#6ee7b7', lineWidth:3});
      drawLandmarks(ctx, lm, {color:'#d1fae5', lineWidth:1, radius:3});

      // highlight tips
      const tips = [TIP.thumb, TIP.index, TIP.middle, TIP.ring, TIP.pinky];
      tips.forEach(i => {
        const p = toPx(lm[i]);
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,0.75)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 12, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      });
    }

    function onResults(results){
      resizeCanvas();

      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;

      ctx.clearRect(0,0,w,h);
      if (!results.image) return;

      // Draw video frame onto canvas (mirrored)
      ctx.save();
      ctx.scale(-1, 1);
      ctx.drawImage(results.image, -w, 0, w, h);
      ctx.restore();

      const hand = results.multiHandLandmarks && results.multiHandLandmarks[0];
      if (!hand){
        setZone('—', 'var(--text)');
        debugEl.textContent = 'No hand detected.';
        return;
      }

      const lm = smoothLandmarks(hand);

      // Evaluate zone + draw overlays
      const evalOut = evaluateZone(lm);
      setZone(evalOut.zone, evalOut.color);
      debugEl.textContent = `meanSigned=${evalOut.meanSigned.toFixed(2)} | mode=${state.mode} | spacing=${state.spacingPx}px`;

      // Skeleton
      drawSkeleton(lm);

      if (state.ibeEnabled && state.overlayEnabled){
        const a = state.bandOpacity;
        fillBetween(evalOut.green, evalOut.acceptable, `rgba(34,197,94,${a})`);
        fillBetween(evalOut.acceptable, evalOut.low, `rgba(59,130,246,${Math.max(0, a-0.04)})`);
        fillCapAbove(evalOut.green, `rgba(109,40,217,${Math.max(0, a-0.08)})`);

        drawLine(evalOut.green, 'var(--good)', 5, true);
        drawLine(evalOut.acceptable, 'var(--ok)', 5, true);
        drawLine(evalOut.low, 'var(--low)', 5, true);

        drawThumbRed(lm);
      }
    }

    // Auto-fill UI values
    spacingVal.textContent = spacing.value;
    opacityVal.textContent = Number(opacity.value).toFixed(2);
    smoothVal.textContent = Number(smooth.value).toFixed(2);

    setStatus('Idle');
    setZone('—');
  </script>
</body>
</html>
