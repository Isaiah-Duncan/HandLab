<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>HandHero ‚Äì IBE Boundary Visualizer</title>
  <style>
    /*
     * ============================================
     * BOUNDARY ARCHITECTURE (CURVED, MODE-BASED)
     * ============================================
     * BOUNDARIES ARE SMOOTH CURVES, NOT STRAIGHT LINES
     * Node selection adapts per exercise mode:
     *
     * GREEN boundary (MCP joints):
     *   - open: all 5 fingers [4, 8, 12, 16, 20]
     *   - scout: index+middle+ring [8, 12, 16]
     *   - pointer: index only [8]
     *   - pinch_ti: index+thumb [4, 8]
     *   - pinch_tp: thumb+pinky [4, 20]
     *
     * BLUE boundary (PIP joints):
     *   - Same mode-based selection as GREEN
     *
     * PURPLE boundary:
     *   - Parallel offset below BLUE (by spacing px)
     *
     * RED THUMB LINE:
     *   - Nodes 2 ‚Üí 4 extended (Thumb MCP ‚Üí TIP)
     *   - Perpendicular offset from palm edge
     *   - Dynamic offset: 0.06 to 0.25 of hand width
     *
     * See buildCurvePoints() for mode-to-nodes mapping
     * ============================================
     */

    :root {
      --bg: #0f1419;
      --card-bg: rgba(255,255,255,0.06);
      --card-border: rgba(255,255,255,0.10);
      --text: #ffffff;
      --text-muted: rgba(255,255,255,0.60);
      --green: #22c55e;
      --blue: #3b82f6;
      --purple: #8b5cf6;
      --red: #ef4444;
      --orange: #f97316;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    html, body {
      width: 100%; height: 100%;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      overflow: hidden;
    }

    /* ============================================
       MAIN LAYOUT
       ============================================ */
    .app {
      position: relative;
      width: 100%;
      height: 100%;
    }

    /* Video is hidden - we draw to canvas */
    #video {
      position: absolute;
      opacity: 0;
      pointer-events: none;
      width: 1px; height: 1px;
    }

    #canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      background: #000;
    }

    /* ============================================
       TOP-LEFT: Instruction Card
       ============================================ */
    .instruction-card {
      position: absolute;
      top: 16px;
      left: 16px;
      background: var(--card-bg);
      backdrop-filter: blur(20px);
      border: 1px solid var(--card-border);
      border-radius: 16px;
      padding: 16px 20px;
      max-width: 320px;
      z-index: 100;
    }

    .instruction-card .icon {
      font-size: 28px;
      margin-bottom: 8px;
    }

    .instruction-card .title {
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 4px;
    }

    .instruction-card .subtitle {
      font-size: 13px;
      color: var(--text-muted);
      margin-bottom: 10px;
    }

    .instruction-card .step-indicator {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      font-weight: 600;
      color: var(--green);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .instruction-card .step-indicator::before {
      content: '';
      width: 8px; height: 8px;
      border-radius: 50%;
      background: var(--green);
    }

    /* ============================================
       TOP-RIGHT: Status Widget
       ============================================ */
    .status-widget {
      position: absolute;
      top: 16px;
      right: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      z-index: 100;
    }

    .status-badge {
      background: rgba(0,0,0,0.5);
      backdrop-filter: blur(10px);
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 1px;
    }

    .status-circle {
      width: 64px;
      height: 64px;
      border-radius: 50%;
      background: var(--card-bg);
      backdrop-filter: blur(20px);
      border: 3px solid var(--card-border);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }

    .status-circle .inner {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: var(--text-muted);
      transition: all 0.3s ease;
    }

    .status-circle.green .inner { background: var(--green); }
    .status-circle.blue .inner { background: var(--blue); }
    .status-circle.yellow .inner { background: var(--orange); }
    .status-circle.red .inner { background: var(--red); }

    .status-label {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* ============================================
       BOTTOM: Stats Row
       ============================================ */
    .stats-row {
      position: absolute;
      bottom: 16px;
      left: 16px;
      display: flex;
      gap: 10px;
      z-index: 100;
    }

    .stat-tile {
      background: var(--card-bg);
      backdrop-filter: blur(20px);
      border: 1px solid var(--card-border);
      border-radius: 12px;
      padding: 10px 16px;
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 90px;
    }

    .stat-tile .icon { font-size: 18px; }
    .stat-tile .value {
      font-size: 20px;
      font-weight: 700;
      font-variant-numeric: tabular-nums;
    }
    .stat-tile .label {
      font-size: 10px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* ============================================
       BOTTOM: Progress Bar
       ============================================ */
    .progress-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: rgba(255,255,255,0.1);
    }

    .progress-bar .fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--green), var(--blue));
      transition: width 0.3s ease;
    }

    /* ============================================
       SETTINGS DRAWER (Bottom-Right)
       ============================================ */
    .settings-toggle {
      position: absolute;
      bottom: 16px;
      right: 16px;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: var(--card-bg);
      backdrop-filter: blur(20px);
      border: 1px solid var(--card-border);
      color: var(--text);
      font-size: 20px;
      cursor: pointer;
      z-index: 110;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .settings-toggle:hover {
      background: rgba(255,255,255,0.12);
      transform: rotate(45deg);
    }

    .settings-drawer {
      position: absolute;
      bottom: 80px;
      right: 16px;
      width: 300px;
      max-height: 70vh;
      overflow-y: auto;
      background: rgba(20,25,35,0.95);
      backdrop-filter: blur(30px);
      border: 1px solid var(--card-border);
      border-radius: 16px;
      padding: 16px;
      z-index: 105;
      display: none;
    }

    .settings-drawer.open { display: block; }

    .settings-drawer h3 {
      font-size: 14px;
      font-weight: 700;
      margin-bottom: 12px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .settings-row {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }

    .settings-btn {
      flex: 1;
      padding: 10px 12px;
      border: 1px solid var(--card-border);
      border-radius: 10px;
      background: rgba(255,255,255,0.06);
      color: var(--text);
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .settings-btn:hover { background: rgba(255,255,255,0.12); }
    .settings-btn.active {
      background: var(--green);
      border-color: var(--green);
      color: #000;
    }

    .settings-slider {
      margin-bottom: 14px;
    }

    .settings-slider label {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: var(--text-muted);
      margin-bottom: 6px;
    }

    .settings-slider input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: rgba(255,255,255,0.15);
      appearance: none;
      cursor: pointer;
    }

    .settings-slider input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--text);
      cursor: pointer;
    }

    select {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--card-border);
      border-radius: 10px;
      background: rgba(255,255,255,0.06);
      color: var(--text);
      font-size: 12px;
      margin-bottom: 12px;
      cursor: pointer;
    }

    .debug-info {
      margin-top: 12px;
      padding: 10px;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      font-size: 11px;
      color: var(--text-muted);
      font-family: monospace;
    }

    /* ============================================
       LEGEND (in Settings)
       ============================================ */
    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 14px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .legend-dot.green { background: var(--green); }
    .legend-dot.blue { background: var(--blue); }
    .legend-dot.purple { background: var(--purple); }
    .legend-dot.red { background: var(--red); }
  </style>
</head>
<body>
  <div class="app">
    <video id="video" playsinline></video>
    <canvas id="canvas"></canvas>

    <!-- TOP-LEFT: Instruction Card -->
    <div class="instruction-card">
      <div class="icon">üññ</div>
      <div class="title" id="exerciseName">IBE Boundary Test</div>
      <div class="subtitle" id="exerciseDesc">Visualizing invisible boundary logic</div>
      <div class="step-indicator" id="stepIndicator">Show your hand to camera</div>
    </div>

    <!-- TOP-RIGHT: Status Widget -->
    <div class="status-widget">
      <div class="status-badge" id="statusBadge">IDLE</div>
      <div class="status-circle" id="statusCircle">
        <div class="inner"></div>
      </div>
      <div class="status-label">STATUS</div>
    </div>

    <!-- BOTTOM: Stats Row -->
    <div class="stats-row">
      <div class="stat-tile">
        <span class="icon">üî•</span>
        <div>
          <div class="value" id="streakVal">0</div>
          <div class="label">Streak</div>
        </div>
      </div>
      <div class="stat-tile">
        <span class="icon">‚ú®</span>
        <div>
          <div class="value" id="doneVal">0</div>
          <div class="label">Done</div>
        </div>
      </div>
      <div class="stat-tile">
        <div class="value" id="timerVal">0:00</div>
        <div class="label">Time</div>
      </div>
    </div>

    <!-- Progress Bar -->
    <div class="progress-bar">
      <div class="fill" id="progressFill"></div>
    </div>

    <!-- Settings Toggle -->
    <button class="settings-toggle" id="settingsToggle">‚öôÔ∏è</button>

    <!-- Settings Drawer -->
    <div class="settings-drawer" id="settingsDrawer">
      <h3>Controls</h3>

      <div class="settings-row">
        <button class="settings-btn active" id="btnStart">‚ñ∂ Start</button>
        <button class="settings-btn" id="btnPause">‚è∏ Pause</button>
      </div>

      <div class="settings-row">
        <button class="settings-btn active" id="btnIBE">üîç IBE: ON</button>
        <button class="settings-btn active" id="btnNodes">üî¢ Nodes: ON</button>
      </div>

      <h3>Test Mode</h3>
      <select id="modeSelect">
        <option value="open">Open Hand (all fingers)</option>
        <option value="scout">Scout Salute (index+middle+ring)</option>
        <option value="pointer">Pointer (index only)</option>
        <option value="pinch_ti">Pinch: Thumb ‚Üí Index</option>
        <option value="pinch_tp">Pinch: Thumb ‚Üí Pinky</option>
      </select>

      <h3>Legend</h3>
      <div class="legend">
        <div class="legend-item"><span class="legend-dot green"></span>Green (18‚Üí6)</div>
        <div class="legend-item"><span class="legend-dot blue"></span>Blue (19‚Üí7)</div>
        <div class="legend-item"><span class="legend-dot purple"></span>Purple (low)</div>
        <div class="legend-item"><span class="legend-dot red"></span>Red (thumb)</div>
      </div>

      <h3>Adjustments</h3>

      <div class="settings-slider">
        <label><span>Zone Opacity</span><span id="opacityVal">0.28</span></label>
        <input type="range" id="opacitySlider" min="0.05" max="0.5" step="0.01" value="0.28">
      </div>

      <div class="settings-slider">
        <label><span>Boundary Spacing</span><span id="spacingVal">40</span></label>
        <input type="range" id="spacingSlider" min="20" max="80" step="2" value="40">
      </div>

      <div class="settings-slider">
        <label><span>Smoothing</span><span id="smoothVal">0.60</span></label>
        <input type="range" id="smoothSlider" min="0" max="0.90" step="0.02" value="0.60">
      </div>

      <div class="debug-info" id="debugInfo">Waiting for camera...</div>
    </div>
  </div>

  <!-- MediaPipe CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    /**
     * ============================================
     * BOUNDARY NODE PAIRS (from wireframe)
     * ============================================
     * GREEN boundary:  nodes 18 ‚Üí 6   (Pinky PIP ‚Üí Index PIP)
     * BLUE boundary:   nodes 19 ‚Üí 7   (Pinky DIP ‚Üí Index DIP)
     * PURPLE boundary: Parallel offset below blue line
     * RED thumb line:  nodes 2 ‚Üí 4    (Thumb MCP ‚Üí TIP, extended)
     * ============================================
     */

    // ============================================
    // STATE
    // ============================================
    const state = {
      running: false,
      paused: false,
      ibeEnabled: true,
      nodesEnabled: true,
      mode: 'open',
      opacity: 0.28,
      spacing: 40,
      smooth: 0.60,
      streak: 0,
      done: 0,
      startTime: null,
    };

    // ============================================
    // DOM ELEMENTS
    // ============================================
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    const statusBadge = document.getElementById('statusBadge');
    const statusCircle = document.getElementById('statusCircle');
    const stepIndicator = document.getElementById('stepIndicator');
    const debugInfo = document.getElementById('debugInfo');

    const settingsToggle = document.getElementById('settingsToggle');
    const settingsDrawer = document.getElementById('settingsDrawer');

    const btnStart = document.getElementById('btnStart');
    const btnPause = document.getElementById('btnPause');
    const btnIBE = document.getElementById('btnIBE');
    const btnNodes = document.getElementById('btnNodes');
    const modeSelect = document.getElementById('modeSelect');

    const opacitySlider = document.getElementById('opacitySlider');
    const opacityVal = document.getElementById('opacityVal');
    const spacingSlider = document.getElementById('spacingSlider');
    const spacingVal = document.getElementById('spacingVal');
    const smoothSlider = document.getElementById('smoothSlider');
    const smoothVal = document.getElementById('smoothVal');

    // ============================================
    // FINGER NODE DEFINITIONS
    // ============================================
    // MediaPipe Hand Landmarks:
    // 0 = Wrist
    // 1-4 = Thumb (CMC, MCP, IP, TIP)
    // 5-8 = Index (MCP, PIP, DIP, TIP)
    // 9-12 = Middle (MCP, PIP, DIP, TIP)
    // 13-16 = Ring (MCP, PIP, DIP, TIP)
    // 17-20 = Pinky (MCP, PIP, DIP, TIP)

    const CONNECTIONS = [
      [0,1],[1,2],[2,3],[3,4],       // Thumb
      [0,5],[5,6],[6,7],[7,8],       // Index
      [0,9],[9,10],[10,11],[11,12],  // Middle
      [0,13],[13,14],[14,15],[15,16],// Ring
      [0,17],[17,18],[18,19],[19,20],// Pinky
      [5,9],[9,13],[13,17]           // Palm
    ];

    const TIPS = [4, 8, 12, 16, 20];
    const PIPS = [2, 6, 10, 14, 18];
    const DIPS = [3, 7, 11, 15, 19];

    // ============================================
    // CANVAS SIZING & VIDEO MAPPING
    // ============================================
    let canvasW = 0, canvasH = 0;
    let videoW = 0, videoH = 0;
    let scale = 1, offsetX = 0, offsetY = 0;

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.round(rect.width * devicePixelRatio);
      canvas.height = Math.round(rect.height * devicePixelRatio);
      canvasW = rect.width;
      canvasH = rect.height;
      ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    }

    function computeVideoMapping() {
      if (!video.videoWidth) return;
      videoW = video.videoWidth;
      videoH = video.videoHeight;

      // Cover: scale to fill canvas, crop overflow
      const scaleX = canvasW / videoW;
      const scaleY = canvasH / videoH;
      scale = Math.max(scaleX, scaleY);

      const scaledW = videoW * scale;
      const scaledH = videoH * scale;

      offsetX = (canvasW - scaledW) / 2;
      offsetY = (canvasH - scaledH) / 2;
    }

    /**
     * Convert normalized landmark to canvas pixel coordinates
     * Handles mirroring (selfie view) and cover aspect ratio
     */
    function toPx(p) {
      // Mirror X for selfie view
      const mirroredX = 1 - p.x;
      
      // Apply cover mapping
      const x = offsetX + mirroredX * videoW * scale;
      const y = offsetY + p.y * videoH * scale;
      
      return { x, y };
    }

    // ============================================
    // SMOOTHING
    // ============================================
    let smoothed = null;

    function smoothLandmarks(lm) {
      if (!lm) return null;
      const a = state.smooth;
      if (!smoothed || smoothed.length !== lm.length) {
        smoothed = lm.map(p => ({ x: p.x, y: p.y, z: p.z }));
        return smoothed;
      }
      for (let i = 0; i < lm.length; i++) {
        smoothed[i].x = smoothed[i].x * a + lm[i].x * (1 - a);
        smoothed[i].y = smoothed[i].y * a + lm[i].y * (1 - a);
        smoothed[i].z = smoothed[i].z * a + lm[i].z * (1 - a);
      }
      return smoothed;
    }

    // ============================================
    // DRAWING: VIDEO
    // ============================================
    function drawVideo(image) {
      ctx.save();
      
      // Mirror the canvas context for selfie view
      ctx.translate(canvasW, 0);
      ctx.scale(-1, 1);
      
      // Draw with cover aspect ratio
      ctx.drawImage(
        image,
        -offsetX, offsetY,  // Adjust for centering
        videoW * scale, videoH * scale
      );
      
      ctx.restore();
    }

    // ============================================
    // DRAWING: SKELETON
    // ============================================
    function drawSkeleton(lm) {
      // Draw connections
      ctx.strokeStyle = '#40E0D0';
      ctx.lineWidth = 2.5;
      ctx.lineCap = 'round';

      for (const [i, j] of CONNECTIONS) {
        const a = toPx(lm[i]);
        const b = toPx(lm[j]);
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      }

      // Draw nodes
      for (let i = 0; i < 21; i++) {
        const p = toPx(lm[i]);
        const isTip = TIPS.includes(i);
        const radius = isTip ? 6 : 4;

        ctx.fillStyle = isTip ? '#40E0D0' : '#40E0D0';
        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1.5;
        ctx.stroke();
      }
    }

    // ============================================
    // DRAWING: NUMBERED NODES
    // ============================================
    function drawNodeNumbers(lm) {
      if (!state.nodesEnabled) return;

      ctx.font = 'bold 10px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      for (let i = 0; i < 21; i++) {
        const p = toPx(lm[i]);

        // Background circle
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.beginPath();
        ctx.arc(p.x, p.y, 10, 0, Math.PI * 2);
        ctx.fill();

        // Border
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1.5;
        ctx.stroke();

        // Number
        ctx.fillStyle = '#fff';
        ctx.fillText(String(i), p.x, p.y);
      }
    }

    // ============================================
    // DRAWING: BOUNDARY LINES & ZONES
    // ============================================

    /**
     * Get line from two node indices and extend it
     */
    function getExtendedLine(lm, nodeA, nodeB, extendPx = 150) {
      const a = toPx(lm[nodeA]);
      const b = toPx(lm[nodeB]);

      // Direction vector
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const len = Math.hypot(dx, dy) || 1;
      const ux = dx / len;
      const uy = dy / len;

      // Extend both ends
      return {
        a: { x: a.x - ux * extendPx, y: a.y - uy * extendPx },
        b: { x: b.x + ux * extendPx, y: b.y + uy * extendPx },
        ux, uy,
        nx: -uy, // Normal (perpendicular)
        ny: ux
      };
    }

    /**
     * Offset a line perpendicular by given pixels
     */
    function offsetLine(line, offsetPx) {
      return {
        a: { x: line.a.x + line.nx * offsetPx, y: line.a.y + line.ny * offsetPx },
        b: { x: line.b.x + line.nx * offsetPx, y: line.b.y + line.ny * offsetPx },
        ux: line.ux, uy: line.uy,
        nx: line.nx, ny: line.ny
      };
    }

    /**
     * Draw a dashed line
     */
    function drawBoundaryLine(line, color, width = 4) {
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.lineCap = 'round';
      ctx.setLineDash([8, 6]);

      ctx.beginPath();
      ctx.moveTo(line.a.x, line.a.y);
      ctx.lineTo(line.b.x, line.b.y);
      ctx.stroke();

      ctx.restore();
    }

    /**
     * Fill zone between two lines
     */
    function fillZoneBetween(topLine, bottomLine, color) {
      ctx.save();
      ctx.fillStyle = color;

      ctx.beginPath();
      ctx.moveTo(topLine.a.x, topLine.a.y);
      ctx.lineTo(topLine.b.x, topLine.b.y);
      ctx.lineTo(bottomLine.b.x, bottomLine.b.y);
      ctx.lineTo(bottomLine.a.x, bottomLine.a.y);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    /**
     * Draw RED thumb line (nodes 2 ‚Üí 4 extended)
     */
    function drawThumbRedLine(lm) {
      const mcp = toPx(lm[2]);  // Thumb MCP
      const tip = toPx(lm[4]);  // Thumb TIP

      // Direction from MCP to TIP
      const dx = tip.x - mcp.x;
      const dy = tip.y - mcp.y;
      const len = Math.hypot(dx, dy) || 1;
      const ux = dx / len;
      const uy = dy / len;

      // Extend the line
      const extendBefore = 60;
      const extendAfter = 80;

      const start = {
        x: mcp.x - ux * extendBefore,
        y: mcp.y - uy * extendBefore
      };
      const end = {
        x: tip.x + ux * extendAfter,
        y: tip.y + uy * extendAfter
      };

      // Draw solid red line
      ctx.save();
      ctx.strokeStyle = '#ef4444';
      ctx.lineWidth = 5;
      ctx.lineCap = 'round';

      ctx.beginPath();
      ctx.moveTo(start.x, start.y);
      ctx.lineTo(end.x, end.y);
      ctx.stroke();

      ctx.restore();
    }

    /**
     * Draw "0%" label in green zone
     */
    function drawZoneLabels(greenLine) {
      const midX = (greenLine.a.x + greenLine.b.x) / 2;
      const midY = (greenLine.a.y + greenLine.b.y) / 2;

      // Position label above the green line
      const labelX = midX + greenLine.nx * -40;
      const labelY = midY + greenLine.ny * -40;

      ctx.save();
      ctx.font = 'bold 24px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fillText('0%', labelX, labelY);
      ctx.restore();
    }

    /**
     * Draw complete IBE visualization
     */
    function drawIBEOverlay(lm) {
      if (!state.ibeEnabled) return;

      const alpha = state.opacity;
      const spacing = state.spacing;

      // Get boundary lines from SPECIFIC NODE PAIRS (wireframe spec)
      // GREEN: nodes 18 ‚Üí 6 (Pinky PIP ‚Üí Index PIP)
      const greenLine = getExtendedLine(lm, 18, 6, 200);

      // BLUE: nodes 19 ‚Üí 7 (Pinky DIP ‚Üí Index DIP)
      const blueLine = getExtendedLine(lm, 19, 7, 200);

      // PURPLE: Parallel offset below blue
      // Calculate offset direction (perpendicular, pointing "down" toward palm)
      const purpleLine = offsetLine(blueLine, spacing);

      // === DRAW ZONES ===
      // Green zone: above green line (we draw a band upward)
      const greenTop = offsetLine(greenLine, -spacing * 1.5);
      fillZoneBetween(greenTop, greenLine, `rgba(34, 197, 94, ${alpha})`);

      // Blue zone: between green and blue
      fillZoneBetween(greenLine, blueLine, `rgba(59, 130, 246, ${alpha * 0.9})`);

      // Purple/Low zone: between blue and purple
      fillZoneBetween(blueLine, purpleLine, `rgba(139, 92, 246, ${alpha * 0.8})`);

      // === DRAW BOUNDARY LINES ===
      drawBoundaryLine(greenLine, '#22c55e', 4);
      drawBoundaryLine(blueLine, '#3b82f6', 4);
      drawBoundaryLine(purpleLine, '#8b5cf6', 4);

      // === DRAW RED THUMB LINE ===
      drawThumbRedLine(lm);

      // === DRAW ZONE LABEL ===
      drawZoneLabels(greenLine);

      return { greenLine, blueLine, purpleLine };
    }

    // ============================================
    // ZONE EVALUATION
    // ============================================
    function evaluateZone(lm, boundaries) {
      if (!boundaries) return 'UNKNOWN';

      const { greenLine, blueLine, purpleLine } = boundaries;

      // Get non-target fingertips based on mode
      const nonTargets = getNonTargetTips();

      // Calculate signed distance of non-target tips to green line
      let totalDist = 0;
      for (const tipIdx of nonTargets) {
        const tip = toPx(lm[tipIdx]);
        const dist = signedDistToLine(tip, greenLine);
        totalDist += dist;
      }

      const avgDist = nonTargets.length > 0 ? totalDist / nonTargets.length : 0;

      // Determine zone based on average distance
      if (avgDist < 0) return 'SAFE';
      if (avgDist < state.spacing * 0.8) return 'ACCEPTABLE';
      if (avgDist < state.spacing * 1.8) return 'LOW';
      return 'VIOLATION';
    }

    function signedDistToLine(point, line) {
      const dx = line.b.x - line.a.x;
      const dy = line.b.y - line.a.y;
      const num = (point.x - line.a.x) * dy - (point.y - line.a.y) * dx;
      const den = Math.hypot(dx, dy) || 1;
      return num / den;
    }

    function getNonTargetTips() {
      const allTips = [4, 8, 12, 16, 20];
      let targets = [];

      switch (state.mode) {
        case 'open':
          targets = [4, 8, 12, 16, 20];
          break;
        case 'scout':
          targets = [8, 12, 16];
          break;
        case 'pointer':
          targets = [8];
          break;
        case 'pinch_ti':
          targets = [4, 8];
          break;
        case 'pinch_tp':
          targets = [4, 20];
          break;
      }

      return allTips.filter(t => !targets.includes(t));
    }

    // ============================================
    // UPDATE UI
    // ============================================
    function updateStatus(zone) {
      statusCircle.className = 'status-circle';

      switch (zone) {
        case 'SAFE':
          statusCircle.classList.add('green');
          statusBadge.textContent = 'SAFE';
          break;
        case 'ACCEPTABLE':
          statusCircle.classList.add('blue');
          statusBadge.textContent = 'OK';
          break;
        case 'LOW':
          statusCircle.classList.add('yellow');
          statusBadge.textContent = 'LOW';
          break;
        case 'VIOLATION':
          statusCircle.classList.add('red');
          statusBadge.textContent = 'FAIL';
          break;
        default:
          statusBadge.textContent = 'IDLE';
      }
    }

    function updateTimer() {
      if (!state.startTime) return;
      const elapsed = Math.floor((Date.now() - state.startTime) / 1000);
      const mins = Math.floor(elapsed / 60);
      const secs = elapsed % 60;
      document.getElementById('timerVal').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    // ============================================
    // MEDIAPIPE RESULTS HANDLER
    // ============================================
    function onResults(results) {
      resizeCanvas();
      computeVideoMapping();

      // Clear canvas
      ctx.clearRect(0, 0, canvasW, canvasH);

      // Draw video (mirrored)
      if (results.image) {
        drawVideo(results.image);
      }

      // Check for hand
      const hand = results.multiHandLandmarks && results.multiHandLandmarks[0];

      if (!hand) {
        updateStatus('IDLE');
        stepIndicator.textContent = 'Show your hand to camera';
        debugInfo.textContent = 'No hand detected';
        return;
      }

      // Smooth landmarks
      const lm = smoothLandmarks(hand);

      // Draw skeleton
      drawSkeleton(lm);

      // Draw IBE overlay and get boundaries
      const boundaries = drawIBEOverlay(lm);

      // Draw node numbers (on top)
      drawNodeNumbers(lm);

      // Evaluate zone
      const zone = evaluateZone(lm, boundaries);
      updateStatus(zone);

      stepIndicator.textContent = `Zone: ${zone} | Mode: ${state.mode}`;
      debugInfo.textContent = `IBE: ${state.ibeEnabled ? 'ON' : 'OFF'} | Nodes: ${state.nodesEnabled ? 'ON' : 'OFF'} | Mode: ${state.mode}`;

      // Update timer
      updateTimer();
    }

    // ============================================
    // MEDIAPIPE SETUP
    // ============================================
    let hands, camera;

    async function start() {
      if (state.running) return;

      resizeCanvas();

      hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
      });

      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6,
      });

      hands.onResults(onResults);

      camera = new Camera(video, {
        onFrame: async () => {
          if (!state.paused && hands) {
            await hands.send({ image: video });
          }
        },
        width: 1280,
        height: 720,
      });

      try {
        await camera.start();
        state.running = true;
        state.startTime = Date.now();
        btnStart.classList.add('active');
        btnStart.textContent = '‚úì Running';
        statusBadge.textContent = 'ON';
        debugInfo.textContent = 'Camera started. Show your hand.';
      } catch (e) {
        statusBadge.textContent = 'ERROR';
        debugInfo.textContent = 'Camera error: ' + e.message;
      }
    }

    // ============================================
    // EVENT HANDLERS
    // ============================================
    window.addEventListener('resize', () => {
      resizeCanvas();
      computeVideoMapping();
    });

    settingsToggle.onclick = () => {
      settingsDrawer.classList.toggle('open');
    };

    btnStart.onclick = start;

    btnPause.onclick = () => {
      state.paused = !state.paused;
      btnPause.textContent = state.paused ? '‚ñ∂ Resume' : '‚è∏ Pause';
      btnPause.classList.toggle('active', state.paused);
    };

    btnIBE.onclick = () => {
      state.ibeEnabled = !state.ibeEnabled;
      btnIBE.textContent = `üîç IBE: ${state.ibeEnabled ? 'ON' : 'OFF'}`;
      btnIBE.classList.toggle('active', state.ibeEnabled);
    };

    btnNodes.onclick = () => {
      state.nodesEnabled = !state.nodesEnabled;
      btnNodes.textContent = `üî¢ Nodes: ${state.nodesEnabled ? 'ON' : 'OFF'}`;
      btnNodes.classList.toggle('active', state.nodesEnabled);
    };

    modeSelect.onchange = (e) => {
      state.mode = e.target.value;
    };

    opacitySlider.oninput = (e) => {
      state.opacity = Number(e.target.value);
      opacityVal.textContent = state.opacity.toFixed(2);
    };

    spacingSlider.oninput = (e) => {
      state.spacing = Number(e.target.value);
      spacingVal.textContent = state.spacing;
    };

    smoothSlider.oninput = (e) => {
      state.smooth = Number(e.target.value);
      smoothVal.textContent = state.smooth.toFixed(2);
    };

    // Close settings when clicking outside
    document.addEventListener('click', (e) => {
      if (!settingsDrawer.contains(e.target) && e.target !== settingsToggle) {
        settingsDrawer.classList.remove('open');
      }
    });

    // Initialize
    resizeCanvas();
  </script>
</body>
</html>