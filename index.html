<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>HandHero ‚Äì Dynamic IBE Boundary Visualizer</title>
  <style>
    /*
     * ============================================
     * DYNAMIC BOUNDARY LINES (ALL FINGERS):
     * ============================================
     * GREEN line:  PIPs  ‚Üí nodes 6, 10, 14, 18  (Index‚ÜíMiddle‚ÜíRing‚ÜíPinky PIP)
     * BLUE line:   DIPs  ‚Üí nodes 7, 11, 15, 19  (Index‚ÜíMiddle‚ÜíRing‚ÜíPinky DIP)
     * PURPLE line: TIPs  ‚Üí nodes 8, 12, 16, 20  (Index‚ÜíMiddle‚ÜíRing‚ÜíPinky TIP)
     * RED line:    Fixed offset from hand (measures thumb crossing)
     * GREEN zone:  Organic blob covering palm below boundaries
     * ============================================
     */

    :root {
      --bg: #0f1419;
      --card-bg: rgba(255,255,255,0.06);
      --card-border: rgba(255,255,255,0.10);
      --text: #ffffff;
      --text-muted: rgba(255,255,255,0.60);
      --green: #22c55e;
      --blue: #3b82f6;
      --purple: #8b5cf6;
      --red: #ef4444;
      --orange: #f97316;
      --yellow: #eab308;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    html, body {
      width: 100%; height: 100%;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      overflow: hidden;
    }

    .app {
      position: relative;
      width: 100%;
      height: 100%;
    }

    #video {
      position: absolute;
      opacity: 0;
      pointer-events: none;
      width: 1px; height: 1px;
    }

    #canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      background: #000;
    }

    /* ============================================
       TOP-LEFT: Instruction Card
       ============================================ */
    .instruction-card {
      position: absolute;
      top: 16px;
      left: 16px;
      background: var(--card-bg);
      backdrop-filter: blur(20px);
      border: 1px solid var(--card-border);
      border-radius: 16px;
      padding: 16px 20px;
      max-width: 340px;
      z-index: 100;
    }

    .instruction-card .icon { font-size: 28px; margin-bottom: 8px; }
    .instruction-card .title { font-size: 18px; font-weight: 700; margin-bottom: 4px; }
    .instruction-card .subtitle { font-size: 13px; color: var(--text-muted); margin-bottom: 10px; }

    .zone-report {
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
      padding: 10px 12px;
      margin-top: 10px;
      font-size: 11px;
      font-family: monospace;
    }

    .zone-report .header {
      font-weight: 700;
      margin-bottom: 6px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .zone-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .zone-item:last-child { border-bottom: none; }

    .zone-dot {
      width: 8px; height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .zone-dot.green { background: var(--green); }
    .zone-dot.blue { background: var(--blue); }
    .zone-dot.purple { background: var(--purple); }
    .zone-dot.red { background: var(--red); animation: pulse 0.5s infinite; }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(1.3); }
    }

    /* ============================================
       TOP-RIGHT: Status Widget
       ============================================ */
    .status-widget {
      position: absolute;
      top: 16px;
      right: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      z-index: 100;
    }

    .status-badge {
      background: rgba(0,0,0,0.5);
      backdrop-filter: blur(10px);
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 1px;
    }

    .status-circle {
      width: 64px;
      height: 64px;
      border-radius: 50%;
      background: var(--card-bg);
      backdrop-filter: blur(20px);
      border: 3px solid var(--card-border);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }

    .status-circle .inner {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: var(--text-muted);
      transition: all 0.3s ease;
    }

    .status-circle.green .inner { background: var(--green); }
    .status-circle.blue .inner { background: var(--blue); }
    .status-circle.purple .inner { background: var(--purple); }
    .status-circle.red .inner { background: var(--red); animation: pulse 0.5s infinite; }

    .status-label {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* ============================================
       BOTTOM: Stats Row
       ============================================ */
    .stats-row {
      position: absolute;
      bottom: 16px;
      left: 16px;
      display: flex;
      gap: 10px;
      z-index: 100;
    }

    .stat-tile {
      background: var(--card-bg);
      backdrop-filter: blur(20px);
      border: 1px solid var(--card-border);
      border-radius: 12px;
      padding: 10px 16px;
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 90px;
    }

    .stat-tile .icon { font-size: 18px; }
    .stat-tile .value { font-size: 20px; font-weight: 700; font-variant-numeric: tabular-nums; }
    .stat-tile .label { font-size: 10px; font-weight: 600; color: var(--text-muted); text-transform: uppercase; }

    /* ============================================
       SETTINGS
       ============================================ */
    .settings-toggle {
      position: absolute;
      bottom: 16px;
      right: 16px;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: var(--card-bg);
      backdrop-filter: blur(20px);
      border: 1px solid var(--card-border);
      color: var(--text);
      font-size: 20px;
      cursor: pointer;
      z-index: 110;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .settings-toggle:hover { background: rgba(255,255,255,0.12); transform: rotate(45deg); }

    .settings-drawer {
      position: absolute;
      bottom: 80px;
      right: 16px;
      width: 300px;
      max-height: 70vh;
      overflow-y: auto;
      background: rgba(20,25,35,0.95);
      backdrop-filter: blur(30px);
      border: 1px solid var(--card-border);
      border-radius: 16px;
      padding: 16px;
      z-index: 105;
      display: none;
    }

    .settings-drawer.open { display: block; }

    .settings-drawer h3 {
      font-size: 12px;
      font-weight: 700;
      margin-bottom: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .settings-row {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }

    .settings-btn {
      flex: 1;
      padding: 10px 12px;
      border: 1px solid var(--card-border);
      border-radius: 10px;
      background: rgba(255,255,255,0.06);
      color: var(--text);
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .settings-btn:hover { background: rgba(255,255,255,0.12); }
    .settings-btn.active { background: var(--green); border-color: var(--green); color: #000; }

    .settings-slider { margin-bottom: 12px; }
    .settings-slider label {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .settings-slider input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: rgba(255,255,255,0.15);
      appearance: none;
      cursor: pointer;
    }

    .settings-slider input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--text);
    }

    select {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--card-border);
      border-radius: 10px;
      background: rgba(255,255,255,0.06);
      color: var(--text);
      font-size: 12px;
      margin-bottom: 10px;
    }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 12px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 10px;
      color: var(--text-muted);
    }

    .legend-line {
      width: 16px;
      height: 3px;
      border-radius: 2px;
    }

    .legend-line.green { background: var(--green); }
    .legend-line.blue { background: var(--blue); }
    .legend-line.purple { background: var(--purple); }
    .legend-line.red { background: var(--red); }
  </style>
</head>
<body>
  <div class="app">
    <video id="video" playsinline></video>
    <canvas id="canvas"></canvas>

    <!-- TOP-LEFT: Instruction Card -->
    <div class="instruction-card">
      <div class="icon">üñêÔ∏è</div>
      <div class="title" id="exerciseName">Dynamic IBE Visualizer</div>
      <div class="subtitle" id="exerciseDesc">Boundaries bend with your fingers</div>
      
      <div class="zone-report" id="zoneReport">
        <div class="header">Finger Zone Report</div>
        <div id="fingerZones">Waiting for hand...</div>
      </div>
    </div>

    <!-- TOP-RIGHT: Status Widget -->
    <div class="status-widget">
      <div class="status-badge" id="statusBadge">IDLE</div>
      <div class="status-circle" id="statusCircle">
        <div class="inner"></div>
      </div>
      <div class="status-label">STATUS</div>
    </div>

    <!-- BOTTOM: Stats Row -->
    <div class="stats-row">
      <div class="stat-tile">
        <span class="icon">üî•</span>
        <div>
          <div class="value" id="streakVal">0</div>
          <div class="label">Streak</div>
        </div>
      </div>
      <div class="stat-tile">
        <span class="icon">‚ú®</span>
        <div>
          <div class="value" id="doneVal">0</div>
          <div class="label">Done</div>
        </div>
      </div>
      <div class="stat-tile">
        <div class="value" id="timerVal">0:00</div>
        <div class="label">Time</div>
      </div>
    </div>

    <!-- Settings Toggle -->
    <button class="settings-toggle" id="settingsToggle">‚öôÔ∏è</button>

    <!-- Settings Drawer -->
    <div class="settings-drawer" id="settingsDrawer">
      <h3>Controls</h3>
      <div class="settings-row">
        <button class="settings-btn active" id="btnStart">‚ñ∂ Start</button>
        <button class="settings-btn" id="btnPause">‚è∏ Pause</button>
      </div>
      <div class="settings-row">
        <button class="settings-btn active" id="btnIBE">üîç IBE</button>
        <button class="settings-btn active" id="btnNodes">üî¢ Nodes</button>
        <button class="settings-btn active" id="btnZones">üé® Zones</button>
      </div>

      <h3>Test Mode</h3>
      <select id="modeSelect">
        <option value="open">Open Hand (all fingers)</option>
        <option value="scout">Scout Salute (index+middle+ring)</option>
        <option value="pointer">Pointer (index only)</option>
        <option value="peace">Peace Sign (index+middle)</option>
        <option value="pinch_ti">Pinch: Thumb ‚Üí Index</option>
        <option value="pinch_tp">Pinch: Thumb ‚Üí Pinky</option>
      </select>

      <h3>Legend</h3>
      <div class="legend">
        <div class="legend-item"><span class="legend-line green"></span>PIP (Safe)</div>
        <div class="legend-item"><span class="legend-line blue"></span>DIP (OK)</div>
        <div class="legend-item"><span class="legend-line purple"></span>TIP (Low)</div>
        <div class="legend-item"><span class="legend-line red"></span>Thumb Line</div>
      </div>

      <h3>Adjustments</h3>
      <div class="settings-slider">
        <label><span>Zone Opacity</span><span id="opacityVal">0.30</span></label>
        <input type="range" id="opacitySlider" min="0.1" max="0.6" step="0.02" value="0.30">
      </div>
      <div class="settings-slider">
        <label><span>Red Line Offset</span><span id="redOffsetVal">80</span></label>
        <input type="range" id="redOffsetSlider" min="40" max="150" step="5" value="80">
      </div>
      <div class="settings-slider">
        <label><span>Smoothing</span><span id="smoothVal">0.55</span></label>
        <input type="range" id="smoothSlider" min="0" max="0.85" step="0.02" value="0.55">
      </div>
    </div>
  </div>

  <!-- MediaPipe CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    /**
     * ============================================
     * DYNAMIC BOUNDARY NODES (ALL FINGERS):
     * ============================================
     * GREEN (PIP):    6, 10, 14, 18  (Index‚ÜíPinky PIPs)
     * BLUE (DIP):     7, 11, 15, 19  (Index‚ÜíPinky DIPs)
     * PURPLE (TIP):   8, 12, 16, 20  (Index‚ÜíPinky TIPs)
     * RED LINE:       Fixed offset from palm edge
     * THUMB NODES:    1, 2, 3, 4     (CMC, MCP, IP, TIP)
     * ============================================
     */

    // ============================================
    // STATE
    // ============================================
    const state = {
      running: false,
      paused: false,
      ibeEnabled: true,
      nodesEnabled: true,
      zonesEnabled: true,
      mode: 'open',
      opacity: 0.30,
      redLineOffset: 80,
      smooth: 0.55,
      startTime: null,
      frameCount: 0,
    };

    // Finger zone tracking
    const fingerZones = {
      thumb: { zone: 'safe', alarm: false },
      index: { zone: 'safe', nodes: [] },
      middle: { zone: 'safe', nodes: [] },
      ring: { zone: 'safe', nodes: [] },
      pinky: { zone: 'safe', nodes: [] },
    };

    // ============================================
    // DOM ELEMENTS
    // ============================================
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    const statusBadge = document.getElementById('statusBadge');
    const statusCircle = document.getElementById('statusCircle');
    const fingerZonesEl = document.getElementById('fingerZones');

    const settingsToggle = document.getElementById('settingsToggle');
    const settingsDrawer = document.getElementById('settingsDrawer');

    // ============================================
    // NODE DEFINITIONS
    // ============================================
    const NODES = {
      WRIST: 0,
      THUMB: { CMC: 1, MCP: 2, IP: 3, TIP: 4 },
      INDEX: { MCP: 5, PIP: 6, DIP: 7, TIP: 8 },
      MIDDLE: { MCP: 9, PIP: 10, DIP: 11, TIP: 12 },
      RING: { MCP: 13, PIP: 14, DIP: 15, TIP: 16 },
      PINKY: { MCP: 17, PIP: 18, DIP: 19, TIP: 20 }
    };

    // Boundary line node groups (for curved lines across all fingers)
    const BOUNDARY_NODES = {
      PIP: [6, 10, 14, 18],   // Green line - PIPs
      DIP: [7, 11, 15, 19],   // Blue line - DIPs
      TIP: [8, 12, 16, 20],   // Purple line - TIPs
      MCP: [5, 9, 13, 17],    // MCPs for safe zone
    };

    const THUMB_NODES = [1, 2, 3, 4];

    const CONNECTIONS = [
      [0,1],[1,2],[2,3],[3,4],
      [0,5],[5,6],[6,7],[7,8],
      [0,9],[9,10],[10,11],[11,12],
      [0,13],[13,14],[14,15],[15,16],
      [0,17],[17,18],[18,19],[19,20],
      [5,9],[9,13],[13,17]
    ];

    const FINGER_NAMES = ['thumb', 'index', 'middle', 'ring', 'pinky'];
    const FINGER_TIPS = { thumb: 4, index: 8, middle: 12, ring: 16, pinky: 20 };

    // ============================================
    // CANVAS & MAPPING
    // ============================================
    let canvasW = 0, canvasH = 0;
    let videoW = 0, videoH = 0;
    let scale = 1, offsetX = 0, offsetY = 0;

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.round(rect.width * devicePixelRatio);
      canvas.height = Math.round(rect.height * devicePixelRatio);
      canvasW = rect.width;
      canvasH = rect.height;
      ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    }

    function computeVideoMapping() {
      if (!video.videoWidth) return;
      videoW = video.videoWidth;
      videoH = video.videoHeight;
      const scaleX = canvasW / videoW;
      const scaleY = canvasH / videoH;
      scale = Math.max(scaleX, scaleY);
      const scaledW = videoW * scale;
      const scaledH = videoH * scale;
      offsetX = (canvasW - scaledW) / 2;
      offsetY = (canvasH - scaledH) / 2;
    }

    function toPx(p) {
      const mirroredX = 1 - p.x;
      return {
        x: offsetX + mirroredX * videoW * scale,
        y: offsetY + p.y * videoH * scale
      };
    }

    // ============================================
    // SMOOTHING
    // ============================================
    let smoothed = null;

    function smoothLandmarks(lm) {
      if (!lm) return null;
      const a = state.smooth;
      if (!smoothed || smoothed.length !== lm.length) {
        smoothed = lm.map(p => ({ x: p.x, y: p.y, z: p.z }));
        return smoothed;
      }
      for (let i = 0; i < lm.length; i++) {
        smoothed[i].x = smoothed[i].x * a + lm[i].x * (1 - a);
        smoothed[i].y = smoothed[i].y * a + lm[i].y * (1 - a);
        smoothed[i].z = smoothed[i].z * a + lm[i].z * (1 - a);
      }
      return smoothed;
    }

    // ============================================
    // DRAWING: VIDEO
    // ============================================
    function drawVideo(image) {
      ctx.save();
      ctx.translate(canvasW, 0);
      ctx.scale(-1, 1);
      ctx.drawImage(image, -offsetX, offsetY, videoW * scale, videoH * scale);
      ctx.restore();
    }

    // ============================================
    // DRAWING: GREEN SAFE ZONE BLOB
    // ============================================
    function drawSafeZoneBlob(lm) {
      if (!state.zonesEnabled) return;

      const alpha = state.opacity;

      // Get key points to form the blob shape
      const wrist = toPx(lm[0]);
      const thumbCMC = toPx(lm[1]);
      const thumbMCP = toPx(lm[2]);
      const indexMCP = toPx(lm[5]);
      const middleMCP = toPx(lm[9]);
      const ringMCP = toPx(lm[13]);
      const pinkyMCP = toPx(lm[17]);

      // Get PIP line points (boundary)
      const indexPIP = toPx(lm[6]);
      const middlePIP = toPx(lm[10]);
      const ringPIP = toPx(lm[14]);
      const pinkyPIP = toPx(lm[18]);

      ctx.save();
      ctx.fillStyle = `rgba(34, 197, 94, ${alpha})`;
      ctx.beginPath();

      // Start from wrist
      ctx.moveTo(wrist.x, wrist.y);

      // Go along the pinky side (wrist ‚Üí pinkyMCP ‚Üí pinkyPIP)
      ctx.lineTo(pinkyMCP.x, pinkyMCP.y);
      ctx.lineTo(pinkyPIP.x, pinkyPIP.y);

      // Follow the PIP boundary line (pinky ‚Üí ring ‚Üí middle ‚Üí index)
      ctx.lineTo(ringPIP.x, ringPIP.y);
      ctx.lineTo(middlePIP.x, middlePIP.y);
      ctx.lineTo(indexPIP.x, indexPIP.y);

      // Go down to indexMCP
      ctx.lineTo(indexMCP.x, indexMCP.y);

      // Along thumb side back to wrist
      ctx.lineTo(thumbMCP.x, thumbMCP.y);
      ctx.lineTo(thumbCMC.x, thumbCMC.y);
      ctx.lineTo(wrist.x, wrist.y);

      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    // ============================================
    // DRAWING: CURVED BOUNDARY LINES
    // ============================================
    function drawCurvedBoundaryLine(lm, nodeIndices, color, lineWidth = 4) {
      if (!state.ibeEnabled) return;

      const points = nodeIndices.map(i => toPx(lm[i]));
      if (points.length < 2) return;

      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.setLineDash([10, 6]);

      ctx.beginPath();

      // Extend line beyond first point
      const firstDir = {
        x: points[0].x - points[1].x,
        y: points[0].y - points[1].y
      };
      const firstLen = Math.hypot(firstDir.x, firstDir.y) || 1;
      const extStart = {
        x: points[0].x + (firstDir.x / firstLen) * 60,
        y: points[0].y + (firstDir.y / firstLen) * 60
      };

      ctx.moveTo(extStart.x, extStart.y);
      ctx.lineTo(points[0].x, points[0].y);

      // Draw through all points with slight curve
      for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
      }

      // Extend line beyond last point
      const lastDir = {
        x: points[points.length - 1].x - points[points.length - 2].x,
        y: points[points.length - 1].y - points[points.length - 2].y
      };
      const lastLen = Math.hypot(lastDir.x, lastDir.y) || 1;
      const extEnd = {
        x: points[points.length - 1].x + (lastDir.x / lastLen) * 60,
        y: points[points.length - 1].y + (lastDir.y / lastLen) * 60
      };

      ctx.lineTo(extEnd.x, extEnd.y);
      ctx.stroke();

      ctx.restore();

      return points;
    }

    // ============================================
    // DRAWING: ZONE FILLS BETWEEN BOUNDARIES
    // ============================================
    function drawZoneFill(topPoints, bottomPoints, color) {
      if (!state.zonesEnabled || !topPoints || !bottomPoints) return;
      if (topPoints.length < 2 || bottomPoints.length < 2) return;

      ctx.save();
      ctx.fillStyle = color;
      ctx.beginPath();

      // Top line (forward)
      ctx.moveTo(topPoints[0].x, topPoints[0].y);
      for (let i = 1; i < topPoints.length; i++) {
        ctx.lineTo(topPoints[i].x, topPoints[i].y);
      }

      // Bottom line (backward)
      for (let i = bottomPoints.length - 1; i >= 0; i--) {
        ctx.lineTo(bottomPoints[i].x, bottomPoints[i].y);
      }

      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    // ============================================
    // DRAWING: FIXED RED LINE (Thumb Measurement)
    // ============================================
    function getRedLine(lm) {
      const wrist = toPx(lm[0]);
      const indexMCP = toPx(lm[5]);
      const middleMCP = toPx(lm[9]);
      const ringMCP = toPx(lm[13]);
      const pinkyMCP = toPx(lm[17]);
      const thumbMCP = toPx(lm[2]);

      // Compute palm center
      const palmCenter = {
        x: (wrist.x + indexMCP.x + middleMCP.x + ringMCP.x + pinkyMCP.x) / 5,
        y: (wrist.y + indexMCP.y + middleMCP.y + ringMCP.y + pinkyMCP.y) / 5,
      };

      // Across-knuckles direction (pinky ‚Üí index)
      const edge = {
        x: pinkyMCP.x - indexMCP.x,
        y: pinkyMCP.y - indexMCP.y
      };
      const edgeLen = Math.hypot(edge.x, edge.y) || 1;

      // Candidate normal (perpendicular to knuckle line)
      let normal = {
        x: -edge.y / edgeLen,
        y: edge.x / edgeLen
      };

      // Pick the normal that points AWAY from the thumb (for right hand, points LEFT)
      const thumbVec = {
        x: thumbMCP.x - palmCenter.x,
        y: thumbMCP.y - palmCenter.y
      };
      const dotTN = thumbVec.x * normal.x + thumbVec.y * normal.y;
      if (dotTN > 0) {
        normal.x *= -1;
        normal.y *= -1;
      }

      // Hand size estimate
      const handSize = Math.max(60, Math.hypot(pinkyMCP.x - indexMCP.x, pinkyMCP.y - indexMCP.y));

      // Palm axis direction (wrist ‚Üí middle MCP)
      const axisRaw = { x: middleMCP.x - wrist.x, y: middleMCP.y - wrist.y };
      const axisLen = Math.hypot(axisRaw.x, axisRaw.y) || 1;
      const axis = { x: axisRaw.x / axisLen, y: axisRaw.y / axisLen };

      // Offset the base point
      const offset = state.redLineOffset;
      const base = {
        x: palmCenter.x + normal.x * offset,
        y: palmCenter.y + normal.y * offset,
      };

      // Extend line endpoints
      const extendBefore = 0.35 * handSize;
      const extendAfter = 1.25 * handSize;

      const start = {
        x: base.x - axis.x * extendBefore,
        y: base.y - axis.y * extendBefore,
      };

      const end = {
        x: base.x + axis.x * extendAfter,
        y: base.y + axis.y * extendAfter,
      };

      // Return with normal and base for crossing detection
      return { start, end, normal, base };
    }

    function drawRedLine(redLine) {
      if (!state.ibeEnabled) return;

      ctx.save();
      ctx.strokeStyle = '#ef4444';
      ctx.lineWidth = 5;
      ctx.lineCap = 'round';
      ctx.setLineDash([]);

      ctx.beginPath();
      ctx.moveTo(redLine.start.x, redLine.start.y);
      ctx.lineTo(redLine.end.x, redLine.end.y);
      ctx.stroke();

      // Add glow effect
      ctx.shadowColor = '#ef4444';
      ctx.shadowBlur = 15;
      ctx.strokeStyle = 'rgba(239, 68, 68, 0.5)';
      ctx.lineWidth = 10;
      ctx.stroke();

      ctx.restore();
    }

    // ============================================
    // THUMB CROSSING DETECTION
    // ============================================
    function checkThumbCrossing(lm, redLine) {
      const crossingNodes = [];

      for (const nodeIdx of THUMB_NODES) {
        const node = toPx(lm[nodeIdx]);

        // Calculate signed distance to red line using normal
        const toNode = {
          x: node.x - redLine.base.x,
          y: node.y - redLine.base.y
        };

        // Dot product with normal (positive = past line toward thumb)
        const dist = toNode.x * redLine.normal.x + toNode.y * redLine.normal.y;

        if (dist > 0) {
          crossingNodes.push(nodeIdx);
        }
      }

      return crossingNodes;
    }

    // ============================================
    // SMART EXERCISE LOGIC (UP vs DOWN fingers)
    // ============================================
    function getExpectedFingerStates(mode) {
      // Returns { fingerName: 'up' | 'down' }
      switch (mode) {
        case 'open':
          // All fingers extended
          return { index: 'up', middle: 'up', ring: 'up', pinky: 'up', thumb: 'up' };
        case 'scout':
          // Scout salute: index+middle+ring UP, thumb+pinky DOWN
          return { index: 'up', middle: 'up', ring: 'up', pinky: 'down', thumb: 'down' };
        case 'pointer':
          // Index only extended
          return { index: 'up', middle: 'down', ring: 'down', pinky: 'down', thumb: 'down' };
        case 'peace':
          // Peace sign: index+middle UP
          return { index: 'up', middle: 'up', ring: 'down', pinky: 'down', thumb: 'down' };
        case 'pinch_ti':
          // Pinch thumb to index: thumb+index UP, others DOWN
          return { index: 'up', middle: 'down', ring: 'down', pinky: 'down', thumb: 'up' };
        case 'pinch_tp':
          // Pinch thumb to pinky: thumb+pinky UP, others DOWN
          return { index: 'down', middle: 'down', ring: 'down', pinky: 'up', thumb: 'up' };
        default:
          return { index: 'up', middle: 'up', ring: 'up', pinky: 'up', thumb: 'up' };
      }
    }

    function computeFingerExtension(lm, fingerName) {
      // Returns true if finger is extended (above PIP), false if folded
      const fingerMeta = {
        index: { tip: 8, pip: 6, dip: 7 },
        middle: { tip: 12, pip: 10, dip: 11 },
        ring: { tip: 16, pip: 14, dip: 15 },
        pinky: { tip: 20, pip: 18, dip: 19 },
        thumb: { tip: 4, pip: 2, dip: 3 }
      };

      const meta = fingerMeta[fingerName];
      if (!meta) return false;

      const tipY = toPx(lm[meta.tip]).y;
      const pipY = toPx(lm[meta.pip]).y;

      // Extended if tip is significantly above PIP (margin ~12px)
      return tipY < pipY - 12;
    }

    function getFingerStateViolations(lm, mode) {
      // Returns { correct: [], wrong: [] } for current vs expected states
      const expected = getExpectedFingerStates(mode);
      const correct = [];
      const wrong = [];

      for (const fingerName of ['index', 'middle', 'ring', 'pinky', 'thumb']) {
        const isExtended = computeFingerExtension(lm, fingerName);
        const expectedState = expected[fingerName];
        const actualState = isExtended ? 'up' : 'down';

        if (actualState === expectedState) {
          correct.push(fingerName);
        } else {
          wrong.push(`${fingerName} (is ${actualState}, need ${expectedState})`);
        }
      }

      return { correct, wrong };
    }

    // ============================================
    // FINGER ZONE DETECTION
    // ============================================
    function detectFingerZones(lm, pipPoints, dipPoints, tipPoints) {
      const zones = {};

      const fingers = [
        { name: 'index', tip: 8, dip: 7, pip: 6, idx: 0 },
        { name: 'middle', tip: 12, dip: 11, pip: 10, idx: 1 },
        { name: 'ring', tip: 16, dip: 15, pip: 14, idx: 2 },
        { name: 'pinky', tip: 20, dip: 19, pip: 18, idx: 3 },
      ];

      for (const finger of fingers) {
        const tipPx = toPx(lm[finger.tip]);
        const dipPx = toPx(lm[finger.dip]);
        const pipPx = toPx(lm[finger.pip]);

        // Get corresponding boundary points for this finger column
        const pipBoundaryY = pipPoints[finger.idx]?.y || 0;
        const dipBoundaryY = dipPoints[finger.idx]?.y || 0;
        const tipBoundaryY = tipPoints[finger.idx]?.y || 0;

        // Determine zone based on Y position (lower Y = higher on screen = extended)
        // Check each node individually for zone crossing
        let zone = 'safe';
        let flash = 'none';  // Flash color: 'none', 'blue' (past green), 'red' (past blue)
        const nodesInZone = [];
        const crossingNodes = [];

        // Check tip position against boundaries
        // Past blue/DIP boundary = RED flash (low accuracy zone)
        if (tipPx.y < dipBoundaryY) {
          flash = 'red';
          zone = 'purple';  // In low accuracy zone (past DIP)
          crossingNodes.push(finger.tip);
          nodesInZone.push(finger.tip, finger.dip, finger.pip);
        }
        // Past green/PIP boundary but not past blue = BLUE flash (entered safe zone)
        else if (tipPx.y < pipBoundaryY) {
          flash = 'blue';
          zone = 'blue';  // In OK zone (past PIP but not past DIP)
          crossingNodes.push(finger.tip);
          nodesInZone.push(finger.tip, finger.dip, finger.pip);
        }
        // Below PIP boundary = safe zone (no flash)
        else {
          zone = 'safe';
          nodesInZone.push(finger.pip, finger.dip, finger.tip);
        }

        // Also check if DIP node crosses boundaries
        if (dipPx.y < dipBoundaryY) {
          crossingNodes.push(finger.dip);
          if (flash !== 'red') flash = 'red';
        } else if (dipPx.y < pipBoundaryY) {
          crossingNodes.push(finger.dip);
          if (flash === 'none') flash = 'blue';
        }

        // Also check if PIP node crosses its boundary
        if (pipPx.y < pipBoundaryY) {
          crossingNodes.push(finger.pip);
          if (flash === 'none') flash = 'blue';
        }

        zones[finger.name] = { zone, nodes: nodesInZone, crossingNodes, tipY: tipPx.y, flash };
      }

      return zones;
    }

    // ============================================
    // DRAWING: SKELETON WITH ZONE GLOW
    // ============================================
    function drawSkeleton(lm, fingerZoneData, thumbCrossing) {
      const zoneColors = {
        green: '#22c55e',
        blue: '#3b82f6',
        purple: '#8b5cf6',
        safe: '#40E0D0',
      };

      // Flash state for boundary crossing
      const flashOn = Math.floor(state.frameCount / 6) % 2 === 0;

      // Draw connections
      ctx.lineWidth = 2.5;
      ctx.lineCap = 'round';

      for (const [i, j] of CONNECTIONS) {
        const a = toPx(lm[i]);
        const b = toPx(lm[j]);

        // Determine color based on zone
        let color = '#40E0D0';
        let useGlow = false;

        // Check if this is a thumb connection
        if (THUMB_NODES.includes(i) || THUMB_NODES.includes(j)) {
          if (thumbCrossing.includes(i) || thumbCrossing.includes(j)) {
            color = flashOn ? '#ef4444' : '#7f1d1d';
            useGlow = true;
          }
        } else {
          // Check finger zones and apply flash colors for boundary crossings
          for (const [fingerName, data] of Object.entries(fingerZoneData)) {
            const fingerNodes = getFingerNodes(fingerName);
            if (fingerNodes.includes(i) || fingerNodes.includes(j)) {
              // Check if this segment has a crossing node
              const hasCrossingNode = data.crossingNodes &&
                (data.crossingNodes.includes(i) || data.crossingNodes.includes(j));

              if (hasCrossingNode && data.flash !== 'none') {
                // Apply flash colors for boundary crossing
                if (data.flash === 'red') {
                  // RED flash for low accuracy zone (past blue boundary)
                  color = flashOn ? '#ef4444' : '#7f1d1d';
                  useGlow = true;
                } else if (data.flash === 'blue') {
                  // BLUE flash for safe zone reached (past green boundary)
                  color = flashOn ? '#3b82f6' : '#1e3a5f';
                  useGlow = true;
                }
              } else {
                color = zoneColors[data.zone] || color;
              }
            }
          }
        }

        // Draw with glow if needed
        if (useGlow && flashOn) {
          ctx.save();
          ctx.shadowColor = color;
          ctx.shadowBlur = 10;
          ctx.strokeStyle = color;
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();
          ctx.restore();
        } else {
          ctx.strokeStyle = color;
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();
        }
      }
    }

    function getFingerNodes(fingerName) {
      switch (fingerName) {
        case 'index': return [5, 6, 7, 8];
        case 'middle': return [9, 10, 11, 12];
        case 'ring': return [13, 14, 15, 16];
        case 'pinky': return [17, 18, 19, 20];
        default: return [];
      }
    }

    // ============================================
    // DRAWING: NODES WITH GLOW
    // ============================================
    function drawNodes(lm, fingerZoneData, thumbCrossing) {
      if (!state.nodesEnabled) return;

      const zoneColors = {
        green: '#22c55e',
        blue: '#3b82f6',
        purple: '#8b5cf6',
        safe: '#40E0D0',
      };

      state.frameCount++;
      const flashOn = Math.floor(state.frameCount / 6) % 2 === 0;

      for (let i = 0; i < 21; i++) {
        const p = toPx(lm[i]);

        // Determine node color
        let fillColor = 'rgba(0,0,0,0.8)';
        let strokeColor = '#fff';
        let glowColor = null;
        let isAlarm = false;

        // Check if thumb node crossing red line
        if (THUMB_NODES.includes(i) && thumbCrossing.includes(i)) {
          fillColor = flashOn ? '#ef4444' : '#7f1d1d';
          strokeColor = '#ef4444';
          glowColor = '#ef4444';
          isAlarm = true;
        } else {
          // Check finger zones and apply boundary crossing flashes
          for (const [fingerName, data] of Object.entries(fingerZoneData)) {
            const fingerNodes = getFingerNodes(fingerName);
            if (fingerNodes.includes(i)) {
              // Check if this specific node is crossing a boundary
              const isCrossingNode = data.crossingNodes && data.crossingNodes.includes(i);

              if (isCrossingNode && data.flash !== 'none') {
                // Apply flash colors for boundary crossings
                if (data.flash === 'red') {
                  // RED flash when past blue boundary (low accuracy zone)
                  fillColor = flashOn ? '#ef4444' : '#7f1d1d';
                  glowColor = '#ef4444';
                  strokeColor = flashOn ? '#ef4444' : '#7f1d1d';
                  isAlarm = true;
                } else if (data.flash === 'blue') {
                  // BLUE flash when past green boundary (safe zone reached)
                  fillColor = flashOn ? '#3b82f6' : '#1e3a5f';
                  glowColor = '#3b82f6';
                  strokeColor = flashOn ? '#3b82f6' : '#1e3a5f';
                }
              } else if (data.zone !== 'safe') {
                // Non-crossing nodes in active zone just get zone color
                glowColor = zoneColors[data.zone];
                strokeColor = glowColor;
              }
            }
          }
        }

        // Draw glow
        if (glowColor) {
          ctx.save();
          ctx.shadowColor = glowColor;
          ctx.shadowBlur = isAlarm ? 20 : 12;
          ctx.fillStyle = glowColor;
          ctx.globalAlpha = flashOn ? 0.5 : 0.3;
          ctx.beginPath();
          ctx.arc(p.x, p.y, 16, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        // Draw node
        ctx.fillStyle = fillColor;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 11, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw number
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 9px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(String(i), p.x, p.y);
      }
    }

    // ============================================
    // UI UPDATE: ZONE REPORT
    // ============================================
    function updateZoneReport(fingerZoneData, thumbCrossing, fingerViolations) {
      let html = '';

      // Show expected finger states for current mode
      const expected = getExpectedFingerStates(state.mode);
      const upFingers = Object.entries(expected).filter(([_, v]) => v === 'up').map(([k]) => k);
      const downFingers = Object.entries(expected).filter(([_, v]) => v === 'down').map(([k]) => k);

      html += `<div class="zone-item" style="font-size:10px;color:var(--text-muted)">
        <span>Expected UP: ${upFingers.length > 0 ? upFingers.join(', ') : 'none'}</span>
      </div>`;
      if (downFingers.length > 0) {
        html += `<div class="zone-item" style="font-size:10px;color:var(--text-muted)">
          <span>Expected DOWN: ${downFingers.join(', ')}</span>
        </div>`;
      }

      // Thumb status
      const thumbStatus = thumbCrossing.length > 0 ? 'CROSSING' : 'OK';
      const thumbClass = thumbCrossing.length > 0 ? 'red' : 'green';
      html += `<div class="zone-item">
        <span class="zone-dot ${thumbClass}"></span>
        <span>Thumb: ${thumbStatus} ${thumbCrossing.length > 0 ? `(nodes: ${thumbCrossing.join(',')})` : ''}</span>
      </div>`;

      // Other fingers
      for (const [name, data] of Object.entries(fingerZoneData)) {
        const dotClass = data.zone === 'safe' ? 'green' : data.zone;
        const flashIndicator = data.flash !== 'none' ? ` [${data.flash.toUpperCase()} FLASH]` : '';
        const crossingText = data.crossingNodes && data.crossingNodes.length > 0
          ? ` (crossing: ${data.crossingNodes.join(',')})`
          : '';
        html += `<div class="zone-item">
          <span class="zone-dot ${dotClass}"></span>
          <span>${name.charAt(0).toUpperCase() + name.slice(1)}: ${data.zone.toUpperCase()}${crossingText}${flashIndicator}</span>
        </div>`;
      }

      // Smart exercise logic report
      if (fingerViolations) {
        if (fingerViolations.wrong.length === 0) {
          html += `<div class="zone-item" style="color:var(--green);font-weight:700">
            <span class="zone-dot green"></span>
            <span>‚úì Exercise pose correct</span>
          </div>`;
        } else {
          html += `<div class="zone-item" style="color:var(--orange);font-weight:700">
            <span class="zone-dot" style="background:var(--orange)"></span>
            <span>‚ö† Violations: ${fingerViolations.wrong.join(', ')}</span>
          </div>`;
        }
      }

      fingerZonesEl.innerHTML = html;
    }

    function updateStatus(fingerZoneData, thumbCrossing) {
      statusCircle.className = 'status-circle';

      // Determine overall status
      const hasThumbAlarm = thumbCrossing.length > 0;
      const zones = Object.values(fingerZoneData).map(d => d.zone);

      if (hasThumbAlarm) {
        statusCircle.classList.add('red');
        statusBadge.textContent = 'ALARM';
      } else if (zones.includes('purple')) {
        statusCircle.classList.add('purple');
        statusBadge.textContent = 'LOW';
      } else if (zones.includes('blue')) {
        statusCircle.classList.add('blue');
        statusBadge.textContent = 'OK';
      } else if (zones.includes('green')) {
        statusCircle.classList.add('green');
        statusBadge.textContent = 'GOOD';
      } else {
        statusCircle.classList.add('green');
        statusBadge.textContent = 'SAFE';
      }
    }

    // ============================================
    // TIMER
    // ============================================
    function updateTimer() {
      if (!state.startTime) return;
      const elapsed = Math.floor((Date.now() - state.startTime) / 1000);
      const mins = Math.floor(elapsed / 60);
      const secs = elapsed % 60;
      document.getElementById('timerVal').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    // ============================================
    // MEDIAPIPE RESULTS
    // ============================================
    function onResults(results) {
      resizeCanvas();
      computeVideoMapping();
      ctx.clearRect(0, 0, canvasW, canvasH);

      if (results.image) {
        drawVideo(results.image);
      }

      const hand = results.multiHandLandmarks && results.multiHandLandmarks[0];

      if (!hand) {
        statusBadge.textContent = 'IDLE';
        statusCircle.className = 'status-circle';
        fingerZonesEl.innerHTML = '<span style="color:var(--text-muted)">Show your hand...</span>';
        return;
      }

      const lm = smoothLandmarks(hand);

      // 1. Draw safe zone blob (background)
      drawSafeZoneBlob(lm);

      // 2. Draw curved boundary lines and get points
      const pipPoints = BOUNDARY_NODES.PIP.map(i => toPx(lm[i]));
      const dipPoints = BOUNDARY_NODES.DIP.map(i => toPx(lm[i]));
      const tipPoints = BOUNDARY_NODES.TIP.map(i => toPx(lm[i]));

      // 3. Draw zone fills between boundaries
      const alpha = state.opacity;
      drawZoneFill(pipPoints, dipPoints, `rgba(59, 130, 246, ${alpha})`);  // Blue between PIP-DIP
      drawZoneFill(dipPoints, tipPoints, `rgba(139, 92, 246, ${alpha * 0.9})`); // Purple between DIP-TIP

      // 4. Draw boundary lines
      drawCurvedBoundaryLine(lm, BOUNDARY_NODES.PIP, '#22c55e', 4);  // Green
      drawCurvedBoundaryLine(lm, BOUNDARY_NODES.DIP, '#3b82f6', 4);  // Blue
      drawCurvedBoundaryLine(lm, BOUNDARY_NODES.TIP, '#8b5cf6', 4);  // Purple

      // 5. Red line
      const redLine = getRedLine(lm);
      drawRedLine(redLine);

      // 6. Detect zones
      const fingerZoneData = detectFingerZones(lm, pipPoints, dipPoints, tipPoints);
      const thumbCrossing = checkThumbCrossing(lm, redLine);

      // 6b. Check exercise-specific finger states
      const fingerViolations = getFingerStateViolations(lm, state.mode);

      // 7. Draw skeleton with zone colors
      drawSkeleton(lm, fingerZoneData, thumbCrossing);

      // 8. Draw numbered nodes with glow
      drawNodes(lm, fingerZoneData, thumbCrossing);

      // 9. Update UI
      updateZoneReport(fingerZoneData, thumbCrossing, fingerViolations);
      updateStatus(fingerZoneData, thumbCrossing);
      updateTimer();
    }

    // ============================================
    // MEDIAPIPE SETUP
    // ============================================
    let hands, camera;

    async function start() {
      if (state.running) return;
      resizeCanvas();

      hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
      });

      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6,
      });

      hands.onResults(onResults);

      camera = new Camera(video, {
        onFrame: async () => {
          if (!state.paused && hands) {
            await hands.send({ image: video });
          }
        },
        width: 1280,
        height: 720,
      });

      try {
        await camera.start();
        state.running = true;
        state.startTime = Date.now();
        document.getElementById('btnStart').classList.add('active');
        document.getElementById('btnStart').textContent = '‚úì Running';
        statusBadge.textContent = 'ON';
      } catch (e) {
        statusBadge.textContent = 'ERROR';
        console.error(e);
      }
    }

    // ============================================
    // EVENT HANDLERS
    // ============================================
    window.addEventListener('resize', () => {
      resizeCanvas();
      computeVideoMapping();
    });

    settingsToggle.onclick = () => settingsDrawer.classList.toggle('open');

    document.getElementById('btnStart').onclick = start;

    document.getElementById('btnPause').onclick = function() {
      state.paused = !state.paused;
      this.textContent = state.paused ? '‚ñ∂ Resume' : '‚è∏ Pause';
      this.classList.toggle('active', state.paused);
    };

    document.getElementById('btnIBE').onclick = function() {
      state.ibeEnabled = !state.ibeEnabled;
      this.textContent = state.ibeEnabled ? 'üîç IBE' : 'üîç IBE';
      this.classList.toggle('active', state.ibeEnabled);
    };

    document.getElementById('btnNodes').onclick = function() {
      state.nodesEnabled = !state.nodesEnabled;
      this.textContent = state.nodesEnabled ? 'üî¢ Nodes' : 'üî¢ Nodes';
      this.classList.toggle('active', state.nodesEnabled);
    };

    document.getElementById('btnZones').onclick = function() {
      state.zonesEnabled = !state.zonesEnabled;
      this.textContent = state.zonesEnabled ? 'üé® Zones' : 'üé® Zones';
      this.classList.toggle('active', state.zonesEnabled);
    };

    document.getElementById('modeSelect').onchange = (e) => state.mode = e.target.value;

    document.getElementById('opacitySlider').oninput = function() {
      state.opacity = Number(this.value);
      document.getElementById('opacityVal').textContent = state.opacity.toFixed(2);
    };

    document.getElementById('redOffsetSlider').oninput = function() {
      state.redLineOffset = Number(this.value);
      document.getElementById('redOffsetVal').textContent = state.redLineOffset;
    };

    document.getElementById('smoothSlider').oninput = function() {
      state.smooth = Number(this.value);
      document.getElementById('smoothVal').textContent = state.smooth.toFixed(2);
    };

    document.addEventListener('click', (e) => {
      if (!settingsDrawer.contains(e.target) && e.target !== settingsToggle) {
        settingsDrawer.classList.remove('open');
      }
    });

    resizeCanvas();
  </script>
</body>
</html>